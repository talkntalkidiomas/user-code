declare module "wix-loyalty.v2" {
    const __debug$4: {
        verboseLogging: {
            on: () => boolean;
            off: () => boolean;
        };
    };
    /**
     * A loyalty account stores a customer's loyalty points balance. A site's customers can earn points to their account
     * and redeem those points for rewards.
     */
    interface LoyaltyAccount {
        /**
         * Account ID.
         * @readonly
         */
        _id?: string;
        /**
         * Account owner's contact ID. See the [Contacts API](wix-crm-backend/contacts) to learn more.
         * @readonly
         */
        contactId?: string;
        /**
         * Account owner's member ID. See the [Members API](wix-members-backend/introduction) to learn more.
         * @readonly
         */
        memberId?: string | null;
        /** Information about the account totals. */
        points?: Points;
        /** Details of the account's latest transaction. */
        latestTransaction?: LatestTransaction;
        /**
         * Whether the account has a reward available. `true` if the amount of points in `points.balance` are enough to redeem for a reward.
         * @readonly
         */
        rewardAvailable?: boolean;
        /**
         * Date and time the account was created.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * Date and time the account was last updated.
         * @readonly
         */
        _updatedDate?: Date;
        /**
         * Account's last activity date and time.
         * @readonly
         */
        lastActivityDate?: Date;
        /**
         * Revision number, which increments by 1 each time the loyalty account is updated.
         *
         * To prevent conflicting changes, the current `revision` must be passed when updating the loyalty account.
         *
         * Ignored when creating an account.
         */
        revision?: string;
        /**
         * Tier information.
         *
         * The Loyalty Tiers API is currently unavailable, but the program may be activated and managed from a site's
         * [loyalty dashboard](https://www.wix.com/my-account/site-selector/?buttonText=Select%20Site&title=Select%20a%20Site&autoSelectOnSingleSite=true&actionUrl=https:%2F%2Fwww.wix.com%2Fdashboard%2F%7B%7BmetaSiteId%7D%7D%2Floyalty-accounts/wizard/).
         */
        tier?: Tier$1;
        contact?: Contact;
    }
    interface Points {
        /**
         * Current point balance.
         *
         * Equal to the sum of `earned` and `adjusted` points, minus `redeemed` points.
         */
        balance?: number;
        /** Total earned points. */
        earned?: number;
        /** Total adjusted points. */
        adjusted?: number;
        /** Total redeemed points. */
        redeemed?: number;
    }
    interface LatestTransaction extends LatestTransactionTypeOptionsOneOf {
        /** Transaction ID. */
        _id?: string;
        /** Amount of earned, adjusted, or redeemed points in the latest transaction. */
        amount?: number;
        /**
         * Transaction type.
         *
         * + `"ADJUST"`: Point balance was manually adjusted to a loyalty account. See [`adjustPoints()`](wix-loyalty-v2/accounts/adjustpoints).
         * + `"EARN"`: Points were earned by the customer taking an action. See [`earnPoints()`](wix-loyalty-v2/accounts/earnpoints).
         * + `"GIVE"`: Points were manually added to or subtracted from a loyalty account. See [`adjustPoints()`](wix-loyalty-v2/accounts/adjustpoints).
         * + `"REDEEM"`: Points were redeemed by the customer for a reward.
         */
        type?: TransactionType;
        /**
         * Description of the latest transaction.
         *
         * Max: 100 characters
         */
        description?: string;
        /**
         * Date and time the transaction was created.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * ID of the app that initiated the transaction.
         *
         * Only present if `type` is `"EARN"` or `"ADJUST"`. The `appId` can be set to any string when points are manually earned or adjusted. When points are earned or adjusted in an automatic event, the `appId` is from that automation's `sourceAppId`.
         * @readonly
         */
        appId?: string | null;
        /**
         * Unique string identifier generated by the app. Wix uses this identifier to recognize subsequent retries of the same request.
         *
         * Only present if points were added manually using the [`earnPoints()`](/wix-loyalty-v2/accounts/earnpoints) function.
         * @readonly
         */
        idempotencyKey?: string | null;
        /**
         * Additional information for redeemed points.
         *
         * Only present if `type` is `"REDEEM"`.
         * @readonly
         */
        redeemInfo?: RedeemInfo;
    }
    /** @oneof */
    interface LatestTransactionTypeOptionsOneOf {
    }
    enum TransactionType {
        UNKNOWN = "UNKNOWN",
        EARN = "EARN",
        REDEEM = "REDEEM",
        ADJUST = "ADJUST",
        GIVE = "GIVE",
        REFUND = "REFUND"
    }
    interface AdjustOptions {
        amountBefore?: number | null;
        amountAfter?: number | null;
    }
    interface EarnOptions {
        activityType?: string | null;
    }
    interface RedeemInfo {
        /**
         * ID of the reward that was redeemed.
         * @readonly
         */
        rewardId?: string;
        /**
         * Type of reward that was redeemed.
         * @readonly
         */
        rewardType?: string;
        /**
         * ID of the specific item that was redeemed in this transaction.
         *
         * Each reward that is redeemed has a unique `referenceEntityId`.
         * @readonly
         */
        referenceEntityId?: string;
    }
    /**
     * Tier information.
     *
     * The Tiers API is currently unavailable, but the program may be activated and managed from a site's
     * [loyalty dashboard](https://www.wix.com/my-account/site-selector/?buttonText=Select%20Site&title=Select%20a%20Site&autoSelectOnSingleSite=true&actionUrl=https:%2F%2Fwww.wix.com%2Fdashboard%2F%7B%7BmetaSiteId%7D%7D%2Floyalty-accounts/wizard/).
     */
    interface Tier$1 {
        /**
         * Tier ID.
         *
         * This field will not be returned if the account belongs to the base tier.
         * @readonly
         */
        _id?: string | null;
        /**
         * Date and time the tier information was last recalculated.
         * @readonly
         */
        _updatedDate?: Date;
        /** Points earned and adjusted over the tier's current rolling window. */
        points?: number;
    }
    /** Loyalty account's contact information */
    interface Contact {
        /**
         * Contact's id
         * @readonly
         */
        _id?: string | null;
        /**
         * Contact's firstName & lastName concatenated
         * @readonly
         */
        name?: string | null;
        /**
         * Contact's profile picture
         * @readonly
         */
        picture?: Image;
        /**
         * Contact's email
         * @readonly
         */
        email?: string | null;
        /**
         * Contact's firstName & lastName concatenated, or email if name doesn't exist
         * @readonly
         */
        displayName?: string | null;
    }
    interface Image {
        /** WixMedia image ID. */
        _id?: string;
        /** Image URL. */
        url?: string;
        /**
         * Original image height.
         * @readonly
         */
        height?: number;
        /**
         * Original image width.
         * @readonly
         */
        width?: number;
    }
    interface RewardAvailabilityUpdated {
        rewardAvailable?: boolean;
        updateTrigger?: UpdateTrigger;
    }
    enum UpdateTrigger {
        UNDEFINED = "UNDEFINED",
        REWARD_UPDATED = "REWARD_UPDATED",
        BALANCE_UPDATED = "BALANCE_UPDATED",
        TIERS_RECALCULATED = "TIERS_RECALCULATED"
    }
    interface CreateAccountRequest {
        /**
         * Contact ID for a Wix site contact. See the [Contacts API](wix-crm-backend/contacts) to learn more.
         *
         */
        contactId: string;
    }
    interface CreateAccountResponse {
        /** Created loyalty account. */
        account?: LoyaltyAccount;
    }
    interface EarnPointsRequest {
        /** Loyalty account ID. */
        accountId: string;
        /**
         * Amount of points to earn. Must be a positive, whole number.
         *
         * Min: `1`
         *
         * Max: `9999999`
         */
        amount?: number;
        /**
         * Description of how the points were earned.
         *
         * Max: 100 characters
         */
        description?: string;
        /**
         * ID of the app that initiated the transaction.
         *
         * If points were earned manually, then the `appId` is the Loyalty app's
         * `wixAppId` of `553c79f3-5625-4f38-b14b-ef7c0d1e87df`. If points were earned in an automatic event,
         * then the `appId` is from that automation's `sourceAppId`.
         */
        appId: string;
        /** Unique string identifier generated by the app. Wix uses this identifier to recognize subsequent retries of the same request. */
        idempotencyKey: string;
        /**
         * Activity type
         *
         * If points were earned through automation it should be set to trigger key.
         */
        activityType?: string | null;
    }
    interface EarnPointsResponse {
        /** Updated loyalty account. */
        account?: LoyaltyAccount;
    }
    interface PointsUpdated {
        /** Updated account. */
        account?: LoyaltyAccount;
    }
    interface AdjustPointsRequest extends AdjustPointsRequestTypeOneOf {
        /**
         * Sets the account's point balance to this amount. Must be a positive, whole number or zero.
         *
         * The net difference between this new balance and the previous balance will be reflected in the `adjusted` field of the customer's account.
         *
         * Min: `0`
         *
         * Max: `999999999`
         */
        balance?: number;
        /**
         * Adjusts the account's point balance by this amount. Must be a whole number with a maximum of 7 digits.
         * The amount can be negative, but cannot be `0`.
         *
         * Min: `-9999999`
         *
         * Max: `9999999`
         */
        amount?: number;
        /**
         * Adjusts the account's point balance by this amount. Also account's "redeemed points" is reduced by this amount.
         * Must be a whole number with a maximum of 7 digits.
         * The amount can be negative, but cannot be `0`.
         *
         * Min: `-9999999`
         *
         * Max: `9999999`
         */
        refund?: number;
        /** Loyalty account ID. */
        accountId: string;
        /** Description to explain the reason for the points adjustment. */
        description?: string | null;
        /**
         * Each time the loyalty account is updated, `revision` increments by 1.
         *
         * The current `revision` must be passed when adjusting points in the loyalty account. This
         * ensures you're working with the latest version of the loyalty account and prevents unintended overwrites.
         */
        revision?: string;
    }
    /** @oneof */
    interface AdjustPointsRequestTypeOneOf {
        /**
         * Sets the account's point balance to this amount. Must be a positive, whole number or zero.
         *
         * The net difference between this new balance and the previous balance will be reflected in the `adjusted` field of the customer's account.
         *
         * Min: `0`
         *
         * Max: `999999999`
         */
        balance?: number;
        /**
         * Adjusts the account's point balance by this amount. Must be a whole number with a maximum of 7 digits.
         * The amount can be negative, but cannot be `0`.
         *
         * Min: `-9999999`
         *
         * Max: `9999999`
         */
        amount?: number;
        /**
         * Adjusts the account's point balance by this amount. Also account's "redeemed points" is reduced by this amount.
         * Must be a whole number with a maximum of 7 digits.
         * The amount can be negative, but cannot be `0`.
         *
         * Min: `-9999999`
         *
         * Max: `9999999`
         */
        refund?: number;
    }
    interface AdjustPointsResponse {
        /** Adjusted loyalty account. */
        account?: LoyaltyAccount;
    }
    interface RedeemPointsRequest {
        /** Loyalty account ID. */
        accountId: string;
        /** Reward ID. See [Rewards API](https://dev.wix.com/api/rest/loyalty/rewards/rewards-object) for more details. */
        rewardId: string;
        /** Number of times the given reward will be redeemed. Must be a positive whole number. */
        count?: number;
        /**
         * Revision number, which increments by 1 each time points are redeemed.
         * To prevent conflicting changes, the existing `revision` must be used when redeeming points.
         */
        revision?: string;
        /** Id of the entity that is being redeemed (e.g. orderId for order discount, couponId for coupon reward). */
        referenceEntityId?: string | null;
    }
    interface RedeemPointsResponse {
        /** Loyalty account. */
        account?: LoyaltyAccount;
    }
    interface RedeemDeterminedAmountOfPointsRequest {
        /** Loyalty account ID. */
        accountId: string;
        /** Reward ID. See [Rewards API](https://dev.wix.com/api/rest/loyalty/rewards/rewards-object) for more details. */
        rewardId: string;
        /** Number of points to be redeemed off the account. */
        points?: number;
        /**
         * Revision number, which increments by 1 each time points are redeemed.
         * To prevent conflicting changes, the existing `revision` must be used when redeeming points.
         */
        revision?: string;
        /** Id of the entity that is being redeemed (e.g. orderId for order discount, couponId for coupon reward). */
        referenceEntityId?: string | null;
    }
    interface RedeemDeterminedAmountOfPointsResponse {
        /** Loyalty account. */
        account?: LoyaltyAccount;
    }
    interface GetAccountRequest {
        /** ID of the account to retrieve. */
        _id: string;
    }
    interface GetAccountResponse {
        /** Retrieved loyalty account. */
        account?: LoyaltyAccount;
    }
    interface ListUserAccountsRequest {
        /** Number of items to load. Minimum `1`, maximum `50`. */
        limit?: number | null;
        /** Number of items to skip in the current sort order. */
        offset?: number | null;
    }
    interface ListUserAccountsResponse {
        /** Loyalty accounts. */
        accounts?: LoyaltyAccountForMetaSite[];
    }
    interface LoyaltyAccountForMetaSite {
        /** Loyalty account. */
        account?: LoyaltyAccount;
        /** Metasite ID. */
        metaSiteId?: string;
    }
    interface GetProgramTotalsRequest {
    }
    interface GetProgramTotalsResponse {
        /** Point totals for the entire program. */
        points?: Points;
    }
    interface TierTotal {
        /**
         * If None, Account belongs to base Tier
         * @readonly
         */
        _id?: string | null;
        /** Total number of loyalty accounts, that belongs to particular Tier */
        numberOfAccounts?: number;
    }
    interface GetCurrentMemberAccountRequest {
    }
    interface GetCurrentMemberAccountResponse {
        /** Loyalty account. */
        account?: LoyaltyAccount;
    }
    interface GetAccountBySecondaryIdRequest extends GetAccountBySecondaryIdRequestIdOneOf {
        /** Account owner's contact ID. See the [Contacts API](wix-crm-backend/contacts) to learn more. */
        contactId?: string;
        /** Account owner's member ID. See the [Members API](wix-members-backend/introduction) to learn more. */
        memberId?: string;
    }
    /** @oneof */
    interface GetAccountBySecondaryIdRequestIdOneOf {
        /** Account owner's contact ID. See the [Contacts API](wix-crm-backend/contacts) to learn more. */
        contactId?: string;
        /** Account owner's member ID/ See the [Members API](wix-members-backend/introduction) to learn more. */
        memberId?: string;
    }
    interface GetAccountBySecondaryIdResponse {
        /** Retrieved loyalty account. */
        account?: LoyaltyAccount;
    }
    /** Options to use when retrieving a list of loyalty accounts. */
    interface ListAccountsRequest {
        /** List of contact IDs. See the [Contacts API](wix-crm-backend/contacts) to learn more. */
        contactIds?: string[];
        /** Pagination options. */
        cursorPaging?: CursorPaging$2;
    }
    interface CursorPaging$2 {
        /** Number of items to load. */
        limit?: number | null;
        /**
         * Pointer to the next or previous page in the list of results.
         *
         * You can get the relevant cursor token
         * from the `pagingMetadata` object in the previous call's response.
         * Not relevant for the first request.
         */
        cursor?: string | null;
    }
    interface ListAccountsResponse {
        /** Retrieved loyalty accounts. */
        accounts?: LoyaltyAccount[];
        /** Details on the paged set of results returned. */
        pagingMetadata?: PagingMetadataV2$2;
    }
    interface PagingMetadataV2$2 {
        /** Number of items returned in the response. */
        count?: number | null;
        /** Offset that was requested. */
        offset?: number | null;
        /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
        total?: number | null;
        /** Flag that indicates the server failed to calculate the `total` field. */
        tooManyToCount?: boolean | null;
        /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
        cursors?: Cursors$2;
    }
    interface Cursors$2 {
        /** Cursor pointing to next page in the list of results. */
        next?: string | null;
        /** Cursor pointing to previous page in the list of results. */
        prev?: string | null;
    }
    /** Options to use when search for loyalty accounts. */
    interface SearchAccountsRequest {
        search?: CursorSearch;
    }
    interface CursorSearch extends CursorSearchPagingMethodOneOf {
        /** Cursor pointing to page of results. Can't be used together with 'paging'. 'cursor_paging.cursor' can not be used together with 'filter' or 'sort' */
        cursorPaging?: CursorPaging$2;
        /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
        filter?: Record<string, any> | null;
        /** Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}] */
        sort?: Sorting$2[];
        /** Aggregations | Faceted search: refers to a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition. */
        aggregations?: Aggregation[];
        /** free text to match in searchable fields */
        search?: SearchDetails;
    }
    /** @oneof */
    interface CursorSearchPagingMethodOneOf {
        /** Cursor pointing to page of results. Can't be used together with 'paging'. 'cursor_paging.cursor' can not be used together with 'filter' or 'sort' */
        cursorPaging?: CursorPaging$2;
    }
    interface Sorting$2 {
        /** Name of the field to sort by. */
        fieldName?: string;
        /** Sort order. */
        order?: SortOrder$2;
    }
    enum SortOrder$2 {
        ASC = "ASC",
        DESC = "DESC"
    }
    interface Aggregation extends AggregationKindOneOf {
        value?: ValueAggregation;
        range?: RangeAggregation;
        scalar?: ScalarAggregation;
        name?: string | null;
        type?: AggregationType;
        fieldPath?: string;
        groupBy?: GroupByAggregation;
    }
    /** @oneof */
    interface AggregationKindOneOf {
        value?: ValueAggregation;
        range?: RangeAggregation;
        scalar?: ScalarAggregation;
    }
    interface RangeBucket {
        /** Inclusive lower bound of the range. Required if to is not given. */
        from?: number | null;
        /** Exclusive upper bound of the range. Required if from is not given. */
        to?: number | null;
    }
    enum SortType {
        COUNT = "COUNT",
        VALUE = "VALUE"
    }
    enum SortDirection {
        DESC = "DESC",
        ASC = "ASC"
    }
    enum ScalarType {
        UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
        COUNT_DISTINCT = "COUNT_DISTINCT",
        MIN = "MIN",
        MAX = "MAX",
        SUM = "SUM",
        AVG = "AVG"
    }
    interface ValueAggregation {
        sortType?: SortType;
        sortDirection?: SortDirection;
        /** How many aggregations would you like to return? Can be between 1 and 250. 10 is the default. */
        limit?: number | null;
    }
    enum AggregationType {
        UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
        VALUE = "VALUE",
        RANGE = "RANGE",
        SCALAR = "SCALAR"
    }
    interface RangeAggregation {
        buckets?: RangeBucket[];
    }
    interface ScalarAggregation {
        type?: ScalarType;
    }
    interface GroupByAggregation extends GroupByAggregationKindOneOf {
        value?: ValueAggregation;
        name?: string | null;
        fieldPath?: string;
    }
    /** @oneof */
    interface GroupByAggregationKindOneOf {
        value?: ValueAggregation;
    }
    interface SearchDetails {
        /** boolean search mode */
        mode?: Mode;
        /** search term or expression */
        expression?: string | null;
        /** fields to search in. if empty - server will search in own default fields */
        fields?: string[];
        /** flag if should use auto fuzzy search (allowing typos by a managed proximity algorithm) */
        fuzzy?: boolean;
    }
    enum Mode {
        /** any */
        OR = "OR",
        /** all */
        AND = "AND"
    }
    /** Accounts found through provided search capabilities, along with paging and aggregation data of the results. */
    interface SearchAccountsResponse {
        accounts?: LoyaltyAccount[];
        pagingMetadata?: CursorPagingMetadata$1;
        aggregationData?: AggregationData;
    }
    interface CursorPagingMetadata$1 {
        /** Number of items returned in the response. */
        count?: number | null;
        /** Offset that was requested. */
        cursors?: Cursors$2;
        /**
         * Indicates if there are more results after the current page.
         * If `true`, another page of results can be retrieved.
         * If `false`, this is the last page.
         */
        hasNext?: boolean | null;
    }
    interface AggregationData {
        /** key = aggregation name (as derived from search request) */
        results?: AggregationResults[];
    }
    interface ValueAggregationResult {
        value?: string;
        count?: number;
    }
    interface RangeAggregationResult {
        from?: number | null;
        to?: number | null;
        count?: number;
    }
    interface NestedAggregationResults extends NestedAggregationResultsResultOneOf {
        values?: ValueResults;
        ranges?: RangeResults;
        scalar?: ScalarResult;
        name?: string;
        type?: AggregationType;
        fieldPath?: string;
    }
    /** @oneof */
    interface NestedAggregationResultsResultOneOf {
        values?: ValueResults;
        ranges?: RangeResults;
        scalar?: ScalarResult;
    }
    interface ValueResults {
        results?: ValueAggregationResult[];
    }
    interface RangeResults {
        results?: RangeAggregationResult[];
    }
    interface ScalarResult {
        type?: ScalarType;
        value?: number;
    }
    interface NestedValueAggregationResult {
        value?: string;
        nestedResults?: NestedAggregationResults;
    }
    interface GroupByValueResults {
        results?: NestedValueAggregationResult[];
    }
    interface AggregationResults extends AggregationResultsResultOneOf {
        values?: ValueResults;
        ranges?: RangeResults;
        scalar?: ScalarResult;
        groupedByValue?: GroupByValueResults;
        name?: string;
        type?: AggregationType;
        fieldPath?: string;
    }
    /** @oneof */
    interface AggregationResultsResultOneOf {
        values?: ValueResults;
        ranges?: RangeResults;
        scalar?: ScalarResult;
        groupedByValue?: GroupByValueResults;
    }
    /** Options to use when looking up count of loyalty accounts. */
    interface CountAccountsRequest {
        filter?: Record<string, any> | null;
        search?: SearchDetails;
    }
    /** Count of accounts found for given search query */
    interface CountAccountsResponse {
        count?: number;
    }
    /** Retrieves a transaction. */
    interface GetTransactionRequest {
        /** Transaction ID. */
        _id: string | null;
    }
    interface GetTransactionResponse {
        /** Retrieved transaction. */
        transaction?: Transaction;
    }
    /** Loyalty transaction. */
    interface Transaction {
        /**
         * Transaction ID.
         * @readonly
         */
        _id?: string;
        /**
         * Loyalty account ID.
         * @readonly
         */
        accountId?: string;
        /**
         * Account owner's contact ID. See the [Contacts API](wix-crm-backend/contacts) to learn more.
         * @readonly
         */
        contactId?: string;
        /**
         * Account owner's member ID. See the [Members API](wix-members-backend/introduction) to learn more.
         * @readonly
         */
        memberId?: string | null;
        /** Points earned, adjusted, or redeemed in the latest transaction. */
        amount?: number;
        /**
         * Transaction type.
         *
         * + `"ADJUST"`: Point balance was manually adjusted to a loyalty account. See [`adjustPoints()`](wix-loyalty-v2/accounts/adjustpoints).
         * + `"EARN"`: Points were earned by the customer taking an action. See [`earnPoints()`](wix-loyalty-v2/accounts/earnpoints).
         * + `"GIVE"`: Points were manually added to or subtracted from a loyalty account. See [`adjustPoints()`](wix-loyalty-v2/accounts/adjustpoints).
         * + `"REDEEM"`: Points were redeemed by the customer for a reward.
         */
        type?: TransactionType;
        /** Transaction description. Only present for automated transactions of `type` `"EARN"` or `"REDEEM"`, when set by the site owner in the Business Manager. */
        description?: string;
        /**
         * Date and time of the transaction.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * ID of the app that initiated the transaction.
         *
         * Only present if `type` is `"ADJUST`, `"EARN"`, or `"GIVE"`.
         *
         * If points were earned or adjusted manually, then the `appId` is the Loyalty app's
         * `wixAppId` of `553c79f3-5625-4f38-b14b-ef7c0d1e87df`. If points were earned or adjusted in an automatic event,
         * then the `appId` is from that automation's `sourceAppId`.
         * @readonly
         */
        appId?: string | null;
        /**
         * Unique string identifier generated by the app. Wix uses this identifier to recognize subsequent retries of the same request.
         *
         * Only present if points were added manually using the [`earnPoints()`](/wix-loyalty-v2/accounts/earnpoints) function.
         * @readonly
         */
        idempotencyKey?: string | null;
        /**
         * Additional redeem information. Only present if `type` is `"REDEEM"`.
         * @readonly
         */
        redeemInfo?: RedeemInfo;
    }
    interface ListTransactionsRequest {
        /** Loyalty account ID. */
        accountId: string | null;
        /** Pagination options, such as how many results are listed at a time. */
        cursorPaging?: CursorPaging$2;
    }
    interface ListTransactionsResponse {
        /** Retrieved transactions. */
        transactions?: Transaction[];
        /** Details on the paged set of results returned. */
        pagingMetadata?: PagingMetadataV2$2;
    }
    interface DomainEvent$3 extends DomainEventBodyOneOf$3 {
        createdEvent?: EntityCreatedEvent$3;
        updatedEvent?: EntityUpdatedEvent$3;
        deletedEvent?: EntityDeletedEvent$3;
        actionEvent?: ActionEvent$3;
        /**
         * Unique event ID.
         * Allows clients to ignore duplicate webhooks.
         */
        _id?: string;
        /**
         * Assumes actions are also always typed to an entity_type
         * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
         */
        entityFqdn?: string;
        /**
         * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
         * This is although the created/updated/deleted notion is duplication of the oneof types
         * Example: created/updated/deleted/started/completed/email_opened
         */
        slug?: string;
        /** ID of the entity associated with the event. */
        entityId?: string;
        /** Event timestamp. */
        eventTime?: Date;
        /**
         * Whether the event was triggered as a result of a privacy regulation application
         * (for example, GDPR).
         */
        triggeredByAnonymizeRequest?: boolean | null;
        /** If present, indicates the action that triggered the event. */
        originatedFrom?: string | null;
        /**
         * A sequence number defining the order of updates to the underlying entity.
         * For example, given that some entity was updated at 16:00 and than again at 16:01,
         * it is guaranteed that the sequence number of the second update is strictly higher than the first.
         * As the consumer, you can use this value to ensure that you handle messages in the correct order.
         * To do so, you will need to persist this number on your end, and compare the sequence number from the
         * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
         */
        entityEventSequence?: string | null;
    }
    /** @oneof */
    interface DomainEventBodyOneOf$3 {
        createdEvent?: EntityCreatedEvent$3;
        updatedEvent?: EntityUpdatedEvent$3;
        deletedEvent?: EntityDeletedEvent$3;
        actionEvent?: ActionEvent$3;
    }
    interface EntityCreatedEvent$3 {
        entityAsJson?: string;
    }
    interface EntityUpdatedEvent$3 {
        /**
         * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
         * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
         * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
         */
        currentEntityAsJson?: string;
    }
    interface EntityDeletedEvent$3 {
    }
    interface ActionEvent$3 {
        bodyAsJson?: string;
    }
    interface Empty$3 {
    }
    interface AccountsMerged {
        /**
         * Source accounts.
         * @readonly
         */
        sourceAccounts?: LoyaltyAccount[];
        /**
         * Merged account.
         * @readonly
         */
        updatedAccount?: LoyaltyAccount;
    }
    interface TiersRollingUpdate$1 {
    }
    interface TiersProgramSettingsChanged$1 {
        programSettings?: TiersProgramSettings$1;
    }
    /** There can be single TiersSettings per site and it's global (i.e. applies to all program's tiers) */
    interface TiersProgramSettings$1 extends TiersProgramSettingsPeriodOneOf$1 {
        /**
         * *Required.** Period of time used to calculate loyalty points for tier assignment.
         *
         * The loyalty points accumulated during this period determine if the account meets a tier's required point threshold.
         */
        rollingWindow?: RollingWindow$1;
        /** Tiers program status. */
        status?: Status$2;
        /**
         * Revision number, which increments by `"1"` each time the loyalty tiers settings are updated.
         *
         * To prevent conflicting changes, the current `revision` must be passed when updating the loyalty tiers settings.
         */
        revision?: string | null;
        /**
         * Date and time the loyalty tiers program was created.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * Date and time the loyalty tiers program was last updated.
         * @readonly
         */
        _updatedDate?: Date;
        /**
         * Information about the base loyalty tier.
         *
         * The base tier is the default tier for any account that is unassigned for not meeting
         * the required points threshold of any other tier.
         */
        baseTierDefinition?: TierDefinition$1;
    }
    /** @oneof */
    interface TiersProgramSettingsPeriodOneOf$1 {
        /**
         * *Required.** Period of time used to calculate loyalty points for tier assignment.
         *
         * The loyalty points accumulated during this period determine if the account meets a tier's required point threshold.
         */
        rollingWindow?: RollingWindow$1;
    }
    enum Status$2 {
        UNKNOWN = "UNKNOWN",
        /** Tiers are disabled */
        DISABLED = "DISABLED",
        /** Tiers are enabled but not yet active */
        DRAFT = "DRAFT",
        /** Tiers are active */
        ACTIVE = "ACTIVE",
        /** Tiers are paused */
        PAUSED = "PAUSED"
    }
    /** Information about the tier. */
    interface TierDefinition$1 {
        /** Details about the tier icon. */
        icon?: string;
        /**
         * Tier name.
         *
         * Min: 2 characters
         *
         * Max: 50 characters
         */
        name?: string | null;
        /**
         * Tier desciption.
         *
         * Max: 70 characters
         */
        description?: string | null;
    }
    /**
     * *Required.** Period of time used to calculate loyalty points for tier assignment.
     *
     * The loyalty points accumulated during this period determine if the account meets a tier's required point threshold.
     */
    interface RollingWindow$1 {
        /**
         * Number of months to use for the rolling window period.
         *
         * Min: `"12"`
         *
         * Max: `"36"`
         */
        durationInMonths?: number;
    }
    interface SubscriptionEvent extends SubscriptionEventEventOneOf {
        /** Triggered when a subscription is created. */
        created?: SubscriptionCreated;
        /**
         * Triggered when a subscription is assigned to a Wix site, including the initial
         * assignment of a floating subscription or a re-assignement from a different site.
         */
        assigned?: SubscriptionAssigned;
        /** Triggered when a subscription is canceled. */
        cancelled?: SubscriptionCancelled;
        /** Triggered when the subscription's auto renew is turned on. */
        autoRenewTurnedOn?: SubscriptionAutoRenewTurnedOn;
        /** Triggered when the subscription's auto renew is turned off. */
        autoRenewTurnedOff?: SubscriptionAutoRenewTurnedOff;
        /**
         * Triggered when a subscription is unassigned from a Wix site and becomes
         * floating.
         */
        unassigned?: SubscriptionUnassigned;
        /**
         * Triggered when a subscription is transferred from one Wix account to another.
         * A transfer includes cancelling the original subscription and creating a new
         * subscription for the target account. The event returns both the original
         * and the new subscription.
         */
        transferred?: SubscriptionTransferred;
        /** Triggered when a recurring charge succeeds for a subscription. */
        recurringChargeSucceeded?: RecurringChargeSucceeded;
        /**
         * Triggered when a subscription was updated including when its product has been
         * up- or downgraded or the billing cycle is changed.
         */
        contractSwitched?: ContractSwitched;
        /**
         * Triggered when a subscription gets close to the end of its billing cycle.
         * The exact number of days is defined in the billing system.
         */
        nearEndOfPeriod?: SubscriptionNearEndOfPeriod;
        /**
         * Triggered when a subscription is updated and the change doesn't happen
         * immediately but at the end of the current billing cycle.
         */
        pendingChange?: SubscriptionPendingChange;
        /** ID of the subscription's event. */
        eventId?: string | null;
        /**
         * Date and time of the event in
         * [UTC datetime](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)
         * `YYYY-MM-DDThh:mm:ss.sssZ` format.
         */
        eventDate?: Date;
    }
    /** @oneof */
    interface SubscriptionEventEventOneOf {
        /** Triggered when a subscription is created. */
        created?: SubscriptionCreated;
        /**
         * Triggered when a subscription is assigned to a Wix site, including the initial
         * assignment of a floating subscription or a re-assignement from a different site.
         */
        assigned?: SubscriptionAssigned;
        /** Triggered when a subscription is canceled. */
        cancelled?: SubscriptionCancelled;
        /** Triggered when the subscription's auto renew is turned on. */
        autoRenewTurnedOn?: SubscriptionAutoRenewTurnedOn;
        /** Triggered when the subscription's auto renew is turned off. */
        autoRenewTurnedOff?: SubscriptionAutoRenewTurnedOff;
        /**
         * Triggered when a subscription is unassigned from a Wix site and becomes
         * floating.
         */
        unassigned?: SubscriptionUnassigned;
        /**
         * Triggered when a subscription is transferred from one Wix account to another.
         * A transfer includes cancelling the original subscription and creating a new
         * subscription for the target account. The event returns both the original
         * and the new subscription.
         */
        transferred?: SubscriptionTransferred;
        /** Triggered when a recurring charge succeeds for a subscription. */
        recurringChargeSucceeded?: RecurringChargeSucceeded;
        /**
         * Triggered when a subscription was updated including when its product has been
         * up- or downgraded or the billing cycle is changed.
         */
        contractSwitched?: ContractSwitched;
        /**
         * Triggered when a subscription gets close to the end of its billing cycle.
         * The exact number of days is defined in the billing system.
         */
        nearEndOfPeriod?: SubscriptionNearEndOfPeriod;
        /**
         * Triggered when a subscription is updated and the change doesn't happen
         * immediately but at the end of the current billing cycle.
         */
        pendingChange?: SubscriptionPendingChange;
    }
    /** Triggered when a subscription is created. */
    interface SubscriptionCreated {
        /** Created subscription. */
        subscription?: Subscription;
        /** Metadata for the `created` event. */
        metadata?: Record<string, string>;
    }
    /**
     * A subscription holds information about a Premium product that a Wix account
     * owner has purchased including details about the billing.
     */
    interface Subscription {
        /** ID of the subscription. */
        _id?: string;
        /** ID of the Wix account that purchased the subscription. */
        userId?: string;
        /**
         * ID of the [product](https://bo.wix.com/wix-docs/rest/premium/premium-product-catalog-v2/products/product-object)
         * for which the subscription was purchased.
         */
        productId?: string;
        /**
         * Date and time the subscription was created in
         * [UTC datetime](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)
         * `YYYY-MM-DDThh:mm:ss.sssZ` format.
         */
        createdAt?: Date;
        /**
         * Date and time the subscription was last updated in
         * [UTC datetime](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)
         * `YYYY-MM-DDThh:mm:ss.sssZ` format.
         */
        updatedAt?: Date;
        /**
         * ID of the metasite that the subscription is assigned to.
         * Available only when the subscription is assigned to a Wix site.
         * Subscriptions for account level products can't be assigned to a Wix site.
         */
        metaSiteId?: string | null;
        /** Information about the system that manages the subscription's billing. */
        billingReference?: BillingReference;
        /** Information about the billing cycle of the subscription. */
        cycle?: Cycle;
        /**
         * Subscription status.
         *
         * + `UNKNOWN`: Default status.
         * + `AUTO_RENEW_ON`: Subscription is active and automatically renews at the end of the current billing cycle.
         * + `AUTO_RENEW_OFF`: Subscription is active but expires at the end of the current billing cycle.
         * + `MANUAL_RECURRING`: Subscription is active and renews at the end of the current billing cycle, in case the customer takes an action related to the payment.
         * + `CANCELLED`: Subscription isn't active because it has been canceled.
         * + `TRANSFERRED`: Subscription isn't active because it has been transferred to a different account. A different active subscription was created for the target account.
         */
        status?: SubscriptionStatus;
        /**
         * Date and time the subscription was last transferred from one Wix account to
         * another in
         * [UTC datetime](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)
         * `YYYY-MM-DDThh:mm:ss.sssZ` format.
         */
        transferredAt?: Date;
        /**
         * ID of the [product type](https://bo.wix.com/wix-docs/rest/premium/premium-product-catalog-v2/product-types/product-type-object)
         * that the product, for which the subscription was purchased, belongs to.
         */
        productTypeId?: string;
        /** Version number, which increments by 1 each time the subscription is updated. */
        version?: number;
        /**
         * Whether the subscription is active. Includes the statuses
         * `"AUTO_RENEW_ON"`, `"AUTO_RENEW_OFF"`, and `"MANUAL_RECURRING"`.
         */
        active?: boolean;
        /**
         * Date and time the subscription was originally created in
         * [UTC datetime](https://en.wikipedia.org/wiki/Coordinated_Universal_Time)
         * `YYYY-MM-DDThh:mm:ss.sssZ` format.
         * Differs from `createdAt` in case the subscription was originally created for a different Wix account and has been transferred.
         */
        originalCreationDate?: Date;
        /** Custom metadata about the subscription. */
        metadata?: Record<string, string>;
        /**
         * 2-letter country code in
         * [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements)
         * format.
         */
        countryCode?: string | null;
    }
    interface BillingReference {
        /**
         * Name of the billing system that manages the subscription.
         *
         * + `"UNKNOWN"`: Default value.
         * + `"SBS"`: [Wix Billing](https://github.com/wix-p/premium-billing/tree/master/sbs).
         * + `"LICENSER"`:
         * + `"BASS"`: [Billing and Subscriptions System](https://bo.wix.com/wix-docs/rest/drafts/subscriptions-by-billing-by-wix/introduction).
         * + `"RESELLER"`: [External Reseller](https://dev.wix.com/api/rest/account-level-apis/resellers/introduction).
         */
        providerName?: ProviderName;
        /** Current provider reference ID. */
        providerReferenceId?: string | null;
        /** Previous provider reference IDs. Used for when a subscription is extended, specifically for domains. */
        previousProviderReferenceIds?: string[];
    }
    enum ProviderName {
        UNKNOWN = "UNKNOWN",
        SBS = "SBS",
        LICENSER = "LICENSER",
        BASS = "BASS",
        RESELLER = "RESELLER"
    }
    interface Cycle extends CycleCycleSelectorOneOf {
        /** repetitive interval */
        interval?: Interval;
        /** one time */
        oneTime?: OneTime;
    }
    /** @oneof */
    interface CycleCycleSelectorOneOf {
        /** repetitive interval */
        interval?: Interval;
        /** one time */
        oneTime?: OneTime;
    }
    interface Interval {
        /** interval unit of measure */
        unit?: IntervalUnit;
        /** number of interval */
        count?: number;
    }
    enum IntervalUnit {
        /** unknown interval unit */
        UNKNOWN = "UNKNOWN",
        /** day */
        DAY = "DAY",
        /** week */
        WEEK = "WEEK",
        /** month */
        MONTH = "MONTH",
        /** year */
        YEAR = "YEAR"
    }
    interface OneTime {
    }
    enum SubscriptionStatus {
        UNKNOWN = "UNKNOWN",
        AUTO_RENEW_ON = "AUTO_RENEW_ON",
        AUTO_RENEW_OFF = "AUTO_RENEW_OFF",
        MANUAL_RECURRING = "MANUAL_RECURRING",
        CANCELLED = "CANCELLED",
        TRANSFERRED = "TRANSFERRED"
    }
    /**
     * Triggered when a subscription is assigned to a Wix site, including the initial
     * assignment of a floating subscription or a re-assignement from a different site.
     */
    interface SubscriptionAssigned {
        /** Assigned subscription. */
        subscription?: Subscription;
        /** ID of the metasite that the subscription has been assigned to before the update. */
        previousMetaSiteId?: string | null;
    }
    /** Triggered when a subscription is canceled. */
    interface SubscriptionCancelled {
        /** Canceled subscription. */
        subscription?: Subscription;
        /** Details about the cancellation including who canceled the subscription and why. */
        cancellationDetails?: CancellationDetails;
        /**
         * Whether the subscription is canceled immediately or expires at the end of the current billing cycle.
         *
         * Default: `false`
         */
        immediateCancel?: boolean;
    }
    /** Information about the cancellation flow including who canceled the subscription and why it was canceled. */
    interface CancellationDetails {
        /**
         * Cancellation code.
         *
         * Values supported for cancellations on behalf of the billing system: `-1`, `-2`, `-3`, `-4`, `-5`, `-6`, `-7`, `-8`.
         * For cancellations on behalf of the site owner or the service provider `cancellationCode`
         * is taken from the request of
         * [Cancel Immediately Offline](https://bo.wix.com/wix-docs/rest/premium/premium-subscriptions-manager/cancel-immediately-offline).
         *
         * + `-1`: The subscription has been cancelled by the billing system but none of the listed cancellation reasons applies.
         * + `-2`: There were payment problems.
         * + `-3`: There was a chargeback.
         * + `-4`: Customer support has canceled the subscription and issued a refund.
         * + `-5`: The site owner has changed their existing subscription.
         * + `-6`: The subscription has been transferred to a different Wix account.
         * + `-7`: The subscription has been canceled because the site owner hasn't manually authenticated the recurring payment during the subscription's grace period. For example, site owners must manually confirm recurring payments within 40 days when paying with boleto.
         * + `-8`: The Wix account that the subscription belonged to has been deleted.
         */
        cancellationCode?: number | null;
        /**
         * Cancellation reason. For cancellations on behalf of the site owner or the service provider `cancellationReason`
         * is taken from the request of
         * [Cancel Immediately Offline](https://bo.wix.com/wix-docs/rest/premium/premium-subscriptions-manager/cancel-immediately-offline).
         * For cancellations on behalf of the billing system `cancellationReason` is `null` or an empty string.
         */
        cancellationReason?: string | null;
        /**
         * Initiator of the cancellation. For `"USER_REQUESTED"` and `"APP_MANAGED"`,
         * `cancellationCode` and `cancellationReason` are taken from the request of
         * [Cancel Immediately](https://bo.wix.com/wix-docs/rest/premium/premium-subscriptions-manager/cancel-immediately)
         * or [Cancel Immediately Offline](https://bo.wix.com/wix-docs/rest/premium/premium-subscriptions-manager/cancel-immediately-offline).
         * For `"PASSIVE"`, cancellations `cancellationCode` is automatically calculated and `cancellationReason`
         * is `null` or an empty string.
         *
         * + `"UNKNOWN`: Default value.
         * + `"USER_REQUESTED"`:  The Wix account owner has canceled the subscription.
         * + `"APP_MANAGED"`: The service provider has canceled the subscription.
         * + `"PASSIVE"`: The billing system has canceled the subscription. For example, in case of payment failure or fraud.
         */
        initiator?: Initiator;
    }
    enum Initiator {
        UNKNOWN = "UNKNOWN",
        USER_REQUESTED = "USER_REQUESTED",
        APP_MANAGED = "APP_MANAGED",
        PASSIVE = "PASSIVE"
    }
    /** Triggered when the subscription's auto renew is turned on. */
    interface SubscriptionAutoRenewTurnedOn {
        /** Subscription for which auto renew is turned on. */
        subscription?: Subscription;
        /**
         * Supported values: `USER`, `APP`.
         *
         * Information about who turned auto renew on.
         * + `"USER"`: The site owner who purchased the subscription has turned auto renew on.
         * + `"APP"`: The service provider has turned auto renew on.
         */
        initiator?: string | null;
    }
    /** Triggered when the subscription's auto renew is turned off. */
    interface SubscriptionAutoRenewTurnedOff {
        /** Subscription for which auto renew is turned off. */
        subscription?: Subscription;
        /** Details about the cancellation including who canceled the subscription and why. */
        cancellationDetails?: CancellationDetails;
        /**
         * Whether the subscription is immediately canceled or expires at the end of the current billing cycle.
         *
         * Default: `false`
         */
        immediateCancel?: boolean;
    }
    /**
     * Triggered when a subscription is unassigned from a Wix site and becomes
     * floating.
     */
    interface SubscriptionUnassigned {
        /** Unassigned subscription. */
        subscription?: Subscription;
        /** ID of the metasite that the subscription has been assigned to before the event. */
        previousMetaSiteId?: string;
        /**
         * Reason why the subscription is unassigned.
         *
         * + `"UNKNOWN"`: Default value.
         * + `"USER_REQUESTED"`: The Wix account owner has unassigned the subscription.
         * + `"REPLACED_BY_ANOTHER_SUBSCRIPTION"`: A different subscription that replaces this subscription is assigned to the site.
         */
        unassignReason?: UnassignReason;
    }
    enum UnassignReason {
        UNKNOWN = "UNKNOWN",
        USER_REQUESTED = "USER_REQUESTED",
        REPLACED_BY_ANOTHER_SUBSCRIPTION = "REPLACED_BY_ANOTHER_SUBSCRIPTION"
    }
    /**
     * Triggered when a subscription is transferred from one Wix account to another.
     * A transfer includes cancelling the original subscription and creating a new
     * subscription for the target account. The event returns both the original
     * and the new subscription.
     */
    interface SubscriptionTransferred {
        /** Original subscription that was canceled for the transfer. */
        originSubscription?: Subscription;
        /** Newly created subscription for the target account. */
        targetSubscription?: Subscription;
    }
    /** Triggered when a recurring charge succeeds for a subscription. */
    interface RecurringChargeSucceeded {
        /** Subscription for which the recurring charge has succeeded. */
        subscription?: Subscription;
    }
    /**
     * Triggered when a subscription was updated including when its product has been
     * up- or downgraded or the billing cycle is changed.
     */
    interface ContractSwitched {
        /** Updated subscription. */
        subscription?: Subscription;
        /** Billing cycle before the update. */
        previousCycle?: Cycle;
        /** ID of the product belonging to the subscription before the update. */
        previousProductId?: string;
        /** ID of the product type that the subscription's original product belonged to before the update. */
        previousProductTypeId?: string;
        /**
         * Update type. __Note__: Doesn't include information about a product adjustment.
         * For that purpose, see `productAdjustment`.
         *
         * + `"NOT_APPLICABLE"`: Default value.
         * + `"ADDITIONAL_QUANTITY"`: An increased usage quota is added to the subscription. For example, a second mailbox is added to a subscription that previously included a single mailbox.
         * + `"CREDIT_UNUSED_PERIOD"`: The subscription is upgraded and the new price is less than the regular price. The new price applies to every billing cycle, not just the first cycle.
         * + `"REFUND_PRICE_DIFF"`: Not implemented.
         * + `"ADJUST_PERIOD_END"`: Not implemented.
         * + `"DOWNGRADE_GRACE_PERIOD"`: For downgrades during the grace period. In this situation, the site owner hasn’t paid yet and must immediately pay for the downgraded subscription.
         * + `"FULL_AMOUNT_PERIOD"`: For upgrades in which the site owner retains unused benefits. For example, site owners upgrading a Facebook Ads subscription retain their unused FB Ads credit. The unused credit is added to the new credit.
         * + `"END_OF_PERIOD"`: The subscription's billing current cycle is extended because of a downgrade.
         * + `"PENDING_CHANGES"`: The subscription's billing is updated, but the change doesn't apply immediately. Instead, the update becomes effective at the end of current billing cycle.
         * + `"DOWNGRADE_RENEWAL"`: The subscription is downgraded because of a declined payment. This prevents subscriptions from churning.
         */
        contractSwitchType?: ContractSwitchType;
        /**
         * ID of the metasite the subscription has been assigned to previously.
         * Available only in case the subscription is assigned to a different site.
         */
        previousMetaSiteId?: string | null;
        /**
         * Update reason.
         *
         * + `"PRICE_INCREASE"`: The subscription's price has been increased.
         * + `"EXTERNAL_PROVIDER_TRIGGER"`: Any reason other than a price increase.
         */
        contractSwitchReason?: ContractSwitchReason;
        /** Information about the price update. Available only for updates with a price increase. */
        productPriceIncreaseData?: ProductPriceIncreaseData;
        /**
         * Information about a product adjustment. For example, a downgrade.
         * __Note__: This isn't the same as `contractSwitchType`.
         *
         * + `NOT_APPLICABLE`: There is no information about whether the product has been up- or downgraded.
         * + `DOWNGRADE`: The product has been downgraded.
         */
        productAdjustment?: ProductAdjustment;
    }
    /** Copied from SBS */
    enum ContractSwitchType {
        NOT_APPLICABLE = "NOT_APPLICABLE",
        ADDITIONAL_QUANTITY = "ADDITIONAL_QUANTITY",
        CREDIT_UNUSED_PERIOD = "CREDIT_UNUSED_PERIOD",
        REFUND_PRICE_DIFF = "REFUND_PRICE_DIFF",
        ADJUST_PERIOD_END = "ADJUST_PERIOD_END",
        DOWNGRADE_GRACE_PERIOD = "DOWNGRADE_GRACE_PERIOD",
        FULL_AMOUNT_PERIOD = "FULL_AMOUNT_PERIOD",
        END_OF_PERIOD = "END_OF_PERIOD",
        PENDING_CHANGES = "PENDING_CHANGES",
        DOWNGRADE_RENEWAL = "DOWNGRADE_RENEWAL"
    }
    enum ContractSwitchReason {
        EXTERNAL_PROVIDER_TRIGGER = "EXTERNAL_PROVIDER_TRIGGER",
        PRICE_INCREASE = "PRICE_INCREASE"
    }
    /** Triggered when a subscription's price is increased. */
    interface ProductPriceIncreaseData {
        /** Price of the subscription before the update. */
        previousPrice?: string | null;
    }
    /** Triggered when a subscription's product is adusted. */
    enum ProductAdjustment {
        /** flag to show that the ContractSwitchedEvent is not applicable / needed */
        NOT_APPLICABLE = "NOT_APPLICABLE",
        /** flag to show that the ContractSwitchedEvent is a Downgrade */
        DOWNGRADE = "DOWNGRADE"
    }
    /**
     * Triggered when a subscription gets close to the end of its billing cycle.
     * The exact number of days is defined in the billing system.
     */
    interface SubscriptionNearEndOfPeriod {
        /** Subscription that got close to the end of its billing cycle. */
        subscription?: Subscription;
    }
    /**
     * Triggered when a subscription is updated and the change doesn't happen
     * immediately but at the end of the current billing cycle.
     */
    interface SubscriptionPendingChange {
        /** Subscription for which a pending update is triggered. */
        subscription?: Subscription;
    }
    interface ContactSyncRequest {
        contactIds?: string[];
        contactId?: string | null;
    }
    interface BulkUpsertAccountsRequest {
        /** List of contactIds + points to either insert as new loyalty accounts, or update if contacts already exist as loyalty accounts */
        accounts: AccountToUpsert[];
        /** If true, the upserted accounts are returned in response */
        returnAccounts?: boolean;
    }
    interface AccountToUpsert {
        contactId?: string;
        pointsBalance?: number;
    }
    interface BulkUpsertAccountsResponse {
        /** Loyalty accounts that were created or updated */
        result?: BulkAccountResult[];
        /** Numbers of successes and failures */
        metadata?: BulkActionMetadata$2;
    }
    interface BulkAccountResult {
        /** The created/updated account is returned if specified so in request message. */
        account?: LoyaltyAccount;
        /** LoyaltyAccount metadata. */
        metadata?: ItemMetadata$2;
    }
    interface ItemMetadata$2 {
        /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
        _id?: string | null;
        /** Index of the item within the request array. Allows for correlation between request and response items. */
        originalIndex?: number;
        /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
        success?: boolean;
        /** Details about the error in case of failure. */
        error?: ApplicationError$2;
    }
    interface ApplicationError$2 {
        /** Error code. */
        code?: string;
        /** Description of the error. */
        description?: string;
        /** Data related to the error. */
        data?: Record<string, any> | null;
    }
    interface BulkActionMetadata$2 {
        /** Number of items that were successfully processed. */
        totalSuccesses?: number;
        /** Number of items that couldn't be processed. */
        totalFailures?: number;
        /** Number of failures without details because detailed failure threshold was exceeded. */
        undetailedFailures?: number;
    }
    /**
     * Creates a loyalty account for one of a site's contacts.
     *
     * The `createAccount()` function returns a Promise that resolves to the new loyalty account when it is created.
     *
     * To create a new loyalty account, the customer must first be a site contact with a contact ID. See [contacts](wix-crm-backend/contacts) to learn more about a site's contacts. The site must also have an active loyalty program before loyalty accounts can be created. See the [`activateLoyaltyProgram()`](wix-loyalty-v2/programs/activateloyaltyprogram) function to activate a site's loyalty program.
     *
     * >**Note:** Only visitors with **Manage Loyalty** [permissions](https://support.wix.com/en/article/roles-permissions-accessing-roles-permissions) can create a loyalty account. <!--You can override the permissions with the `wix-auth` [`elevate()`](wix-auth/elevate) function.-->
     *
     * This function is not a universal function and runs only on the backend.
     * @public
     * @documentationMaturity preview
     * @requiredField contactId
     * @param contactId - Contact ID for a Wix site contact. See the [Contacts API](wix-crm-backend/contacts) to learn more.
     * @adminMethod
     */
    function createAccount(contactId: string): Promise<CreateAccountResponse>;
    /**
     * Adds points to a loyalty account.
     *
     * The `earnPoints()` function returns a Promise that resolves to the updated loyalty account.
     *
     * Only a positive amount can be added using the `earnPoints()` function, to manually adjust an account's balance for a negative amount, use [`adjustPoints()`](wix-loyalty-v2/accounts/adjustpoints).
     *
     * The `earnPoints()` function allows customers to manually earn points to their loyalty accounts. To use this function you must include an `appId` and an `idempotencyKey`. Any string can be set as the `appId` or `idempotencyKey`. In contrast to when an account earns points through an action taken on your site, the `appId` automatically sets to the source app that generates the points. The transaction `type` is `"EARN"` for points earned this way.
     *
     * >**Note:** Only visitors with **Manage Loyalty** [permissions](https://support.wix.com/en/article/roles-permissions-accessing-roles-permissions) can earn loyalty points. <!--You can override the permissions with the `wix-auth` [`elevate()`](wix-auth/elevate) function.-->
     *
     * This function is not a universal function and runs only on the backend.
     * @param accountId - Loyalty account ID.
     * @public
     * @documentationMaturity preview
     * @requiredField accountId
     * @requiredField options.appId
     * @requiredField options.idempotencyKey
     * @param options - Earn points info.
     * @adminMethod
     */
    function earnPoints(accountId: string, options?: EarnPointsOptions): Promise<EarnPointsResponse>;
    interface EarnPointsOptions {
        /**
         * Amount of points to earn. Must be a positive, whole number.
         *
         * Min: `1`
         *
         * Max: `9999999`
         */
        amount?: number;
        /**
         * Description of how the points were earned.
         *
         * Max: 100 characters
         */
        description?: string;
        /**
         * ID of the app that initiated the transaction.
         *
         * If points were earned manually, then the `appId` is the Loyalty app's
         * `wixAppId` of `553c79f3-5625-4f38-b14b-ef7c0d1e87df`. If points were earned in an automatic event,
         * then the `appId` is from that automation's `sourceAppId`.
         */
        appId: string;
        /** Unique string identifier generated by the app. Wix uses this identifier to recognize subsequent retries of the same request. */
        idempotencyKey: string;
        /**
         * Activity type
         *
         * If points were earned through automation it should be set to trigger key.
         */
        activityType?: string | null;
    }
    /**
     * Adjusts the point balance of a loyalty account.
     *
     * The `adjustPoints()` function returns a Promise that resolves to the updated loyalty account.
     *
     * To adjust the points balance of an account you must include an `accountId`, a `revision` number, and the adjustment to make. You can also leave a description to explain the reason for the points adjustment.
     *
     * There are two ways to adjust the points of a loyalty account:
     * - `balance` allows you to set the total points balance to this new amount. The transaction `type` will return as `"ADJUST"`.
     * - `amount` allows you to alter the points balance by this amount. This amount can be a positive number to increase the points balance or a negative number to decrease the balance. The transaction type will return as `"GIVE"`.
     *
     * An account may not be adjusted to a negative balance. If you pass values in both the `balance` and the `amount` parameters then the `balance` adjustment takes effect and the `amount` adjustment is ignored.
     *
     * >**Note:** Only visitors with **Manage Loyalty** [permissions](https://support.wix.com/en/article/roles-permissions-accessing-roles-permissions) can manually adjust points in a loyalty account. <!--You can override the permissions with the `wix-auth` [`elevate()`](wix-auth/elevate) function.-->
     *
     * This function is not a universal function and runs only on the backend.
     * @param accountId - Loyalty account ID.
     * @public
     * @documentationMaturity preview
     * @requiredField accountId
     * @param options - Options to use when adjusting points.
     * @adminMethod
     */
    function adjustPoints(accountId: string, options?: AdjustPointsOptions): Promise<AdjustPointsResponse>;
    interface AdjustPointsOptions extends AdjustPointsRequestTypeOneOf {
        /** Description to explain the reason for the points adjustment. */
        description?: string | null;
        /**
         * Sets the account's point balance to this amount. Must be a positive, whole number or zero.
         *
         * The net difference between this new balance and the previous balance will be reflected in the `adjusted` field of the customer's account.
         *
         * Min: `0`
         *
         * Max: `999999999`
         */
        balance?: number;
        /**
         * Adjusts the account's point balance by this amount. Must be a whole number with a maximum of 7 digits.
         * The amount can be negative, but cannot be `0`.
         *
         * Min: `-9999999`
         *
         * Max: `9999999`
         */
        amount?: number;
        /**
         * Adjusts the account's point balance by this amount. Also account's "redeemed points" is reduced by this amount.
         * Must be a whole number with a maximum of 7 digits.
         * The amount can be negative, but cannot be `0`.
         *
         * Min: `-9999999`
         *
         * Max: `9999999`
         */
        refund?: number;
        /**
         * Each time the loyalty account is updated, `revision` increments by 1.
         *
         * The current `revision` must be passed when adjusting points in the loyalty account. This
         * ensures you're working with the latest version of the loyalty account and prevents unintended overwrites.
         */
        revision?: string;
    }
    interface RedeemPointsOptions {
        /** Number of times the given reward will be redeemed. Must be a positive whole number. */
        count?: number;
        /**
         * Revision number, which increments by 1 each time points are redeemed.
         * To prevent conflicting changes, the existing `revision` must be used when redeeming points.
         */
        revision?: string;
        /** Id of the entity that is being redeemed (e.g. orderId for order discount, couponId for coupon reward). */
        referenceEntityId?: string | null;
    }
    interface RedeemDeterminedAmountOfPointsOptions {
        /** Number of points to be redeemed off the account. */
        points?: number;
        /**
         * Revision number, which increments by 1 each time points are redeemed.
         * To prevent conflicting changes, the existing `revision` must be used when redeeming points.
         */
        revision?: string;
        /** Id of the entity that is being redeemed (e.g. orderId for order discount, couponId for coupon reward). */
        referenceEntityId?: string | null;
    }
    /**
     * Retrieves an account using the loyalty account ID.
     *
     * The `getAccount()` function returns a Promise that resolves to the specified loyalty account when it is retrieved.
     *
     * You can also get an account using a secondary ID, such as a contact ID or a member ID with the [`getAccountBySecondaryId()`](wix-loyalty-v2/accounts/getaccountbysecondaryid) function.
     *
     * >**Note:** Only visitors with **Manage Loyalty** [permissions](https://support.wix.com/en/article/roles-permissions-accessing-roles-permissions) can retrieve a loyalty account. <!--You can override the permissions with the `wix-auth` [`elevate()`](wix-auth/elevate) function.-->
     *
     * This function is not a universal function and runs only on the backend.
     * @param _id - ID of the account to retrieve.
     * @public
     * @documentationMaturity preview
     * @requiredField _id
     * @adminMethod
     */
    function getAccount(_id: string): Promise<GetAccountResponse>;
    interface ListUserAccountsOptions {
        /** Number of items to load. Minimum `1`, maximum `50`. */
        limit?: number | null;
        /** Number of items to skip in the current sort order. */
        offset?: number | null;
    }
    /**
     * Retrieves the total amount of points earned, redeemed, and adjusted for the entire loyalty program.
     *
     * The `getProgramTotals()` function returns a Promise that resolves to the combined total points for all loyalty accounts in the program.
     *
     * The `balance` is the current total of points outstanding, while the `earned`, `adjusted`, and `redeemed` amounts are the all-time accumulated amounts. The totals include the amounts for all loyalty accounts.
     *
     * >**Note:** Only visitors with **Manage Loyalty** [permissions](https://support.wix.com/en/article/roles-permissions-accessing-roles-permissions) can retrieve the loyalty program totals. <!--You can override the permissions with the `wix-auth` [`elevate()`](wix-auth/elevate) function.-->
     *
     * This function is not a universal function and runs only on the backend.
     * @public
     * @documentationMaturity preview
     * @adminMethod
     */
    function getProgramTotals(): Promise<GetProgramTotalsResponse>;
    /**
     * Retrieves the loyalty account of the specified site contact or member.
     *
     * The `getAccountBySecondaryId()` function returns a Promise that resolves to the specified loyalty account when it is retrieved.
     *
     * This function gets a loyalty account using either a customer's contact ID or member ID. You can also get an account using the loyalty account ID with the [`getAccount()`](wix-loyalty-v2/accounts/getaccount) function.
     *
     * >**Note:** Only visitors with **Manage Loyalty** [permissions](https://support.wix.com/en/article/roles-permissions-accessing-roles-permissions) can retrieve a loyalty account. <!--You can override the permissions with the `wix-auth` [`elevate()`](wix-auth/elevate) function.-->
     *
     * This function is not a universal function and runs only on the backend.
     * @public
     * @documentationMaturity preview
     * @param options - ID of the customer to retrieve loyalty account for.
     * @adminMethod
     */
    function getAccountBySecondaryId(options?: GetAccountBySecondaryIdOptions): Promise<GetAccountBySecondaryIdResponse>;
    interface GetAccountBySecondaryIdOptions extends GetAccountBySecondaryIdRequestIdOneOf {
        /** Account owner's contact ID. See the [Contacts API](wix-crm-backend/contacts) to learn more. */
        contactId?: string;
        /** Account owner's member ID. See the [Members API](wix-members-backend/introduction) to learn more. */
        memberId?: string;
    }
    /**
     * Retrieves a list of loyalty accounts, given the provided filters.
     *
     * The `listAccounts()` function returns a Promise that resolves to a list of loyalty accounts.
     *
     * You can retrieve selected loyalty accounts with an array of `contactIds` or retrieve a list of all of a site's loyalty accounts
     *     with an empty request parameter. Use the `cursorPaging` parameters to limit how many items load at a time.
     *
     * >**Note:** Only visitors with **Manage Loyalty** [permissions](https://support.wix.com/en/article/roles-permissions-accessing-roles-permissions) can retrieve loyalty accounts. <!--You can override the permissions with the `wix-auth` [`elevate()`](wix-auth/elevate) function.-->
     *
     * This function is not a universal function and runs only on the backend.
     * @public
     * @documentationMaturity preview
     * @param options - Options to use when retrieving a list of loyalty accounts.
     * @adminMethod
     */
    function listAccounts(options?: ListAccountsOptions): Promise<ListAccountsResponse>;
    interface ListAccountsOptions {
        /** List of contact IDs. See the [Contacts API](wix-crm-backend/contacts) to learn more. */
        contactIds?: string[];
        /** Pagination options. */
        cursorPaging?: CursorPaging$2;
    }
    interface SearchAccountsOptions {
        search?: CursorSearch;
    }
    interface CountAccountsOptions {
        filter?: Record<string, any> | null;
        search?: SearchDetails;
    }
    /**
     * Retrieves a transaction using the transaction ID.
     *
     * The `getTransaction()` function returns a Promise that resolves to a loyalty transaction.
     *
     * A loyalty transaction includes any activity that changes a loyalty account point balance, such as adjusting, earning, or redeeming loyalty points. If you want to retrieve many, or all, of the transactions for a specific loyalty account, use the [`listTransactions()`](wix-loyalty-v2/accounts/listtransactions) function.
     *
     * >**Note:** Only visitors with **Manage Loyalty** [permissions](https://support.wix.com/en/article/roles-permissions-accessing-roles-permissions) can retrieve a loyalty transaction. <!--You can override the permissions with the `wix-auth` [`elevate()`](wix-auth/elevate) function.-->
     *
     * This function is not a universal function and runs only on the backend.
     * @param _id - Transaction ID.
     * @public
     * @documentationMaturity preview
     * @requiredField _id
     * @adminMethod
     */
    function getTransaction(_id: string | null): Promise<GetTransactionResponse>;
    /**
     * Retrieves a list of transactions for a specified loyalty account.
     *
     * The `listTransactions()` function returns a Promise that resolves to a list of loyalty transactions for the loyalty account specified by the account ID.
     *
     * Loyalty transactions include activities that change a loyalty account point balance, such as adjusting, earning, or redeeming loyalty points. If you want to get a specific transaction use that transaction's ID and the [`getTransaction()`](wix-loyalty-v2/accounts/gettransaction) function.
     *
     * This function is not a universal function and runs only on the backend.
     * @param accountId - Loyalty account ID.
     * @public
     * @documentationMaturity preview
     * @requiredField accountId
     * @param options - Options to use when retrieving a list of loyalty transactions.
     * @adminMethod
     */
    function listTransactions(accountId: string | null, options?: ListTransactionsOptions): Promise<ListTransactionsResponse>;
    interface ListTransactionsOptions {
        /** Pagination options. */
        cursorPaging?: CursorPaging$2;
    }
    interface BulkUpsertAccountsOptions {
        /** If true, the upserted accounts are returned in response */
        returnAccounts?: boolean;
    }
    type loyaltyV1Account_universal_d_LoyaltyAccount = LoyaltyAccount;
    type loyaltyV1Account_universal_d_Points = Points;
    type loyaltyV1Account_universal_d_LatestTransaction = LatestTransaction;
    type loyaltyV1Account_universal_d_LatestTransactionTypeOptionsOneOf = LatestTransactionTypeOptionsOneOf;
    type loyaltyV1Account_universal_d_TransactionType = TransactionType;
    const loyaltyV1Account_universal_d_TransactionType: typeof TransactionType;
    type loyaltyV1Account_universal_d_AdjustOptions = AdjustOptions;
    type loyaltyV1Account_universal_d_EarnOptions = EarnOptions;
    type loyaltyV1Account_universal_d_RedeemInfo = RedeemInfo;
    type loyaltyV1Account_universal_d_Contact = Contact;
    type loyaltyV1Account_universal_d_Image = Image;
    type loyaltyV1Account_universal_d_RewardAvailabilityUpdated = RewardAvailabilityUpdated;
    type loyaltyV1Account_universal_d_UpdateTrigger = UpdateTrigger;
    const loyaltyV1Account_universal_d_UpdateTrigger: typeof UpdateTrigger;
    type loyaltyV1Account_universal_d_CreateAccountRequest = CreateAccountRequest;
    type loyaltyV1Account_universal_d_CreateAccountResponse = CreateAccountResponse;
    type loyaltyV1Account_universal_d_EarnPointsRequest = EarnPointsRequest;
    type loyaltyV1Account_universal_d_EarnPointsResponse = EarnPointsResponse;
    type loyaltyV1Account_universal_d_PointsUpdated = PointsUpdated;
    type loyaltyV1Account_universal_d_AdjustPointsRequest = AdjustPointsRequest;
    type loyaltyV1Account_universal_d_AdjustPointsRequestTypeOneOf = AdjustPointsRequestTypeOneOf;
    type loyaltyV1Account_universal_d_AdjustPointsResponse = AdjustPointsResponse;
    type loyaltyV1Account_universal_d_RedeemPointsRequest = RedeemPointsRequest;
    type loyaltyV1Account_universal_d_RedeemPointsResponse = RedeemPointsResponse;
    type loyaltyV1Account_universal_d_RedeemDeterminedAmountOfPointsRequest = RedeemDeterminedAmountOfPointsRequest;
    type loyaltyV1Account_universal_d_RedeemDeterminedAmountOfPointsResponse = RedeemDeterminedAmountOfPointsResponse;
    type loyaltyV1Account_universal_d_GetAccountRequest = GetAccountRequest;
    type loyaltyV1Account_universal_d_GetAccountResponse = GetAccountResponse;
    type loyaltyV1Account_universal_d_ListUserAccountsRequest = ListUserAccountsRequest;
    type loyaltyV1Account_universal_d_ListUserAccountsResponse = ListUserAccountsResponse;
    type loyaltyV1Account_universal_d_LoyaltyAccountForMetaSite = LoyaltyAccountForMetaSite;
    type loyaltyV1Account_universal_d_GetProgramTotalsRequest = GetProgramTotalsRequest;
    type loyaltyV1Account_universal_d_GetProgramTotalsResponse = GetProgramTotalsResponse;
    type loyaltyV1Account_universal_d_TierTotal = TierTotal;
    type loyaltyV1Account_universal_d_GetCurrentMemberAccountRequest = GetCurrentMemberAccountRequest;
    type loyaltyV1Account_universal_d_GetCurrentMemberAccountResponse = GetCurrentMemberAccountResponse;
    type loyaltyV1Account_universal_d_GetAccountBySecondaryIdRequest = GetAccountBySecondaryIdRequest;
    type loyaltyV1Account_universal_d_GetAccountBySecondaryIdRequestIdOneOf = GetAccountBySecondaryIdRequestIdOneOf;
    type loyaltyV1Account_universal_d_GetAccountBySecondaryIdResponse = GetAccountBySecondaryIdResponse;
    type loyaltyV1Account_universal_d_ListAccountsRequest = ListAccountsRequest;
    type loyaltyV1Account_universal_d_ListAccountsResponse = ListAccountsResponse;
    type loyaltyV1Account_universal_d_SearchAccountsRequest = SearchAccountsRequest;
    type loyaltyV1Account_universal_d_CursorSearch = CursorSearch;
    type loyaltyV1Account_universal_d_CursorSearchPagingMethodOneOf = CursorSearchPagingMethodOneOf;
    type loyaltyV1Account_universal_d_Aggregation = Aggregation;
    type loyaltyV1Account_universal_d_AggregationKindOneOf = AggregationKindOneOf;
    type loyaltyV1Account_universal_d_RangeBucket = RangeBucket;
    type loyaltyV1Account_universal_d_SortType = SortType;
    const loyaltyV1Account_universal_d_SortType: typeof SortType;
    type loyaltyV1Account_universal_d_SortDirection = SortDirection;
    const loyaltyV1Account_universal_d_SortDirection: typeof SortDirection;
    type loyaltyV1Account_universal_d_ScalarType = ScalarType;
    const loyaltyV1Account_universal_d_ScalarType: typeof ScalarType;
    type loyaltyV1Account_universal_d_ValueAggregation = ValueAggregation;
    type loyaltyV1Account_universal_d_AggregationType = AggregationType;
    const loyaltyV1Account_universal_d_AggregationType: typeof AggregationType;
    type loyaltyV1Account_universal_d_RangeAggregation = RangeAggregation;
    type loyaltyV1Account_universal_d_ScalarAggregation = ScalarAggregation;
    type loyaltyV1Account_universal_d_GroupByAggregation = GroupByAggregation;
    type loyaltyV1Account_universal_d_GroupByAggregationKindOneOf = GroupByAggregationKindOneOf;
    type loyaltyV1Account_universal_d_SearchDetails = SearchDetails;
    type loyaltyV1Account_universal_d_Mode = Mode;
    const loyaltyV1Account_universal_d_Mode: typeof Mode;
    type loyaltyV1Account_universal_d_SearchAccountsResponse = SearchAccountsResponse;
    type loyaltyV1Account_universal_d_AggregationData = AggregationData;
    type loyaltyV1Account_universal_d_ValueAggregationResult = ValueAggregationResult;
    type loyaltyV1Account_universal_d_RangeAggregationResult = RangeAggregationResult;
    type loyaltyV1Account_universal_d_NestedAggregationResults = NestedAggregationResults;
    type loyaltyV1Account_universal_d_NestedAggregationResultsResultOneOf = NestedAggregationResultsResultOneOf;
    type loyaltyV1Account_universal_d_ValueResults = ValueResults;
    type loyaltyV1Account_universal_d_RangeResults = RangeResults;
    type loyaltyV1Account_universal_d_ScalarResult = ScalarResult;
    type loyaltyV1Account_universal_d_NestedValueAggregationResult = NestedValueAggregationResult;
    type loyaltyV1Account_universal_d_GroupByValueResults = GroupByValueResults;
    type loyaltyV1Account_universal_d_AggregationResults = AggregationResults;
    type loyaltyV1Account_universal_d_AggregationResultsResultOneOf = AggregationResultsResultOneOf;
    type loyaltyV1Account_universal_d_CountAccountsRequest = CountAccountsRequest;
    type loyaltyV1Account_universal_d_CountAccountsResponse = CountAccountsResponse;
    type loyaltyV1Account_universal_d_GetTransactionRequest = GetTransactionRequest;
    type loyaltyV1Account_universal_d_GetTransactionResponse = GetTransactionResponse;
    type loyaltyV1Account_universal_d_Transaction = Transaction;
    type loyaltyV1Account_universal_d_ListTransactionsRequest = ListTransactionsRequest;
    type loyaltyV1Account_universal_d_ListTransactionsResponse = ListTransactionsResponse;
    type loyaltyV1Account_universal_d_AccountsMerged = AccountsMerged;
    type loyaltyV1Account_universal_d_SubscriptionEvent = SubscriptionEvent;
    type loyaltyV1Account_universal_d_SubscriptionEventEventOneOf = SubscriptionEventEventOneOf;
    type loyaltyV1Account_universal_d_SubscriptionCreated = SubscriptionCreated;
    type loyaltyV1Account_universal_d_Subscription = Subscription;
    type loyaltyV1Account_universal_d_BillingReference = BillingReference;
    type loyaltyV1Account_universal_d_ProviderName = ProviderName;
    const loyaltyV1Account_universal_d_ProviderName: typeof ProviderName;
    type loyaltyV1Account_universal_d_Cycle = Cycle;
    type loyaltyV1Account_universal_d_CycleCycleSelectorOneOf = CycleCycleSelectorOneOf;
    type loyaltyV1Account_universal_d_Interval = Interval;
    type loyaltyV1Account_universal_d_IntervalUnit = IntervalUnit;
    const loyaltyV1Account_universal_d_IntervalUnit: typeof IntervalUnit;
    type loyaltyV1Account_universal_d_OneTime = OneTime;
    type loyaltyV1Account_universal_d_SubscriptionStatus = SubscriptionStatus;
    const loyaltyV1Account_universal_d_SubscriptionStatus: typeof SubscriptionStatus;
    type loyaltyV1Account_universal_d_SubscriptionAssigned = SubscriptionAssigned;
    type loyaltyV1Account_universal_d_SubscriptionCancelled = SubscriptionCancelled;
    type loyaltyV1Account_universal_d_CancellationDetails = CancellationDetails;
    type loyaltyV1Account_universal_d_Initiator = Initiator;
    const loyaltyV1Account_universal_d_Initiator: typeof Initiator;
    type loyaltyV1Account_universal_d_SubscriptionAutoRenewTurnedOn = SubscriptionAutoRenewTurnedOn;
    type loyaltyV1Account_universal_d_SubscriptionAutoRenewTurnedOff = SubscriptionAutoRenewTurnedOff;
    type loyaltyV1Account_universal_d_SubscriptionUnassigned = SubscriptionUnassigned;
    type loyaltyV1Account_universal_d_UnassignReason = UnassignReason;
    const loyaltyV1Account_universal_d_UnassignReason: typeof UnassignReason;
    type loyaltyV1Account_universal_d_SubscriptionTransferred = SubscriptionTransferred;
    type loyaltyV1Account_universal_d_RecurringChargeSucceeded = RecurringChargeSucceeded;
    type loyaltyV1Account_universal_d_ContractSwitched = ContractSwitched;
    type loyaltyV1Account_universal_d_ContractSwitchType = ContractSwitchType;
    const loyaltyV1Account_universal_d_ContractSwitchType: typeof ContractSwitchType;
    type loyaltyV1Account_universal_d_ContractSwitchReason = ContractSwitchReason;
    const loyaltyV1Account_universal_d_ContractSwitchReason: typeof ContractSwitchReason;
    type loyaltyV1Account_universal_d_ProductPriceIncreaseData = ProductPriceIncreaseData;
    type loyaltyV1Account_universal_d_ProductAdjustment = ProductAdjustment;
    const loyaltyV1Account_universal_d_ProductAdjustment: typeof ProductAdjustment;
    type loyaltyV1Account_universal_d_SubscriptionNearEndOfPeriod = SubscriptionNearEndOfPeriod;
    type loyaltyV1Account_universal_d_SubscriptionPendingChange = SubscriptionPendingChange;
    type loyaltyV1Account_universal_d_ContactSyncRequest = ContactSyncRequest;
    type loyaltyV1Account_universal_d_BulkUpsertAccountsRequest = BulkUpsertAccountsRequest;
    type loyaltyV1Account_universal_d_AccountToUpsert = AccountToUpsert;
    type loyaltyV1Account_universal_d_BulkUpsertAccountsResponse = BulkUpsertAccountsResponse;
    type loyaltyV1Account_universal_d_BulkAccountResult = BulkAccountResult;
    const loyaltyV1Account_universal_d_createAccount: typeof createAccount;
    const loyaltyV1Account_universal_d_earnPoints: typeof earnPoints;
    type loyaltyV1Account_universal_d_EarnPointsOptions = EarnPointsOptions;
    const loyaltyV1Account_universal_d_adjustPoints: typeof adjustPoints;
    type loyaltyV1Account_universal_d_AdjustPointsOptions = AdjustPointsOptions;
    type loyaltyV1Account_universal_d_RedeemPointsOptions = RedeemPointsOptions;
    type loyaltyV1Account_universal_d_RedeemDeterminedAmountOfPointsOptions = RedeemDeterminedAmountOfPointsOptions;
    const loyaltyV1Account_universal_d_getAccount: typeof getAccount;
    type loyaltyV1Account_universal_d_ListUserAccountsOptions = ListUserAccountsOptions;
    const loyaltyV1Account_universal_d_getProgramTotals: typeof getProgramTotals;
    const loyaltyV1Account_universal_d_getAccountBySecondaryId: typeof getAccountBySecondaryId;
    type loyaltyV1Account_universal_d_GetAccountBySecondaryIdOptions = GetAccountBySecondaryIdOptions;
    const loyaltyV1Account_universal_d_listAccounts: typeof listAccounts;
    type loyaltyV1Account_universal_d_ListAccountsOptions = ListAccountsOptions;
    type loyaltyV1Account_universal_d_SearchAccountsOptions = SearchAccountsOptions;
    type loyaltyV1Account_universal_d_CountAccountsOptions = CountAccountsOptions;
    const loyaltyV1Account_universal_d_getTransaction: typeof getTransaction;
    const loyaltyV1Account_universal_d_listTransactions: typeof listTransactions;
    type loyaltyV1Account_universal_d_ListTransactionsOptions = ListTransactionsOptions;
    type loyaltyV1Account_universal_d_BulkUpsertAccountsOptions = BulkUpsertAccountsOptions;
    namespace loyaltyV1Account_universal_d {
        export { __debug$4 as __debug, loyaltyV1Account_universal_d_LoyaltyAccount as LoyaltyAccount, loyaltyV1Account_universal_d_Points as Points, loyaltyV1Account_universal_d_LatestTransaction as LatestTransaction, loyaltyV1Account_universal_d_LatestTransactionTypeOptionsOneOf as LatestTransactionTypeOptionsOneOf, loyaltyV1Account_universal_d_TransactionType as TransactionType, loyaltyV1Account_universal_d_AdjustOptions as AdjustOptions, loyaltyV1Account_universal_d_EarnOptions as EarnOptions, loyaltyV1Account_universal_d_RedeemInfo as RedeemInfo, Tier$1 as Tier, loyaltyV1Account_universal_d_Contact as Contact, loyaltyV1Account_universal_d_Image as Image, loyaltyV1Account_universal_d_RewardAvailabilityUpdated as RewardAvailabilityUpdated, loyaltyV1Account_universal_d_UpdateTrigger as UpdateTrigger, loyaltyV1Account_universal_d_CreateAccountRequest as CreateAccountRequest, loyaltyV1Account_universal_d_CreateAccountResponse as CreateAccountResponse, loyaltyV1Account_universal_d_EarnPointsRequest as EarnPointsRequest, loyaltyV1Account_universal_d_EarnPointsResponse as EarnPointsResponse, loyaltyV1Account_universal_d_PointsUpdated as PointsUpdated, loyaltyV1Account_universal_d_AdjustPointsRequest as AdjustPointsRequest, loyaltyV1Account_universal_d_AdjustPointsRequestTypeOneOf as AdjustPointsRequestTypeOneOf, loyaltyV1Account_universal_d_AdjustPointsResponse as AdjustPointsResponse, loyaltyV1Account_universal_d_RedeemPointsRequest as RedeemPointsRequest, loyaltyV1Account_universal_d_RedeemPointsResponse as RedeemPointsResponse, loyaltyV1Account_universal_d_RedeemDeterminedAmountOfPointsRequest as RedeemDeterminedAmountOfPointsRequest, loyaltyV1Account_universal_d_RedeemDeterminedAmountOfPointsResponse as RedeemDeterminedAmountOfPointsResponse, loyaltyV1Account_universal_d_GetAccountRequest as GetAccountRequest, loyaltyV1Account_universal_d_GetAccountResponse as GetAccountResponse, loyaltyV1Account_universal_d_ListUserAccountsRequest as ListUserAccountsRequest, loyaltyV1Account_universal_d_ListUserAccountsResponse as ListUserAccountsResponse, loyaltyV1Account_universal_d_LoyaltyAccountForMetaSite as LoyaltyAccountForMetaSite, loyaltyV1Account_universal_d_GetProgramTotalsRequest as GetProgramTotalsRequest, loyaltyV1Account_universal_d_GetProgramTotalsResponse as GetProgramTotalsResponse, loyaltyV1Account_universal_d_TierTotal as TierTotal, loyaltyV1Account_universal_d_GetCurrentMemberAccountRequest as GetCurrentMemberAccountRequest, loyaltyV1Account_universal_d_GetCurrentMemberAccountResponse as GetCurrentMemberAccountResponse, loyaltyV1Account_universal_d_GetAccountBySecondaryIdRequest as GetAccountBySecondaryIdRequest, loyaltyV1Account_universal_d_GetAccountBySecondaryIdRequestIdOneOf as GetAccountBySecondaryIdRequestIdOneOf, loyaltyV1Account_universal_d_GetAccountBySecondaryIdResponse as GetAccountBySecondaryIdResponse, loyaltyV1Account_universal_d_ListAccountsRequest as ListAccountsRequest, CursorPaging$2 as CursorPaging, loyaltyV1Account_universal_d_ListAccountsResponse as ListAccountsResponse, PagingMetadataV2$2 as PagingMetadataV2, Cursors$2 as Cursors, loyaltyV1Account_universal_d_SearchAccountsRequest as SearchAccountsRequest, loyaltyV1Account_universal_d_CursorSearch as CursorSearch, loyaltyV1Account_universal_d_CursorSearchPagingMethodOneOf as CursorSearchPagingMethodOneOf, Sorting$2 as Sorting, SortOrder$2 as SortOrder, loyaltyV1Account_universal_d_Aggregation as Aggregation, loyaltyV1Account_universal_d_AggregationKindOneOf as AggregationKindOneOf, loyaltyV1Account_universal_d_RangeBucket as RangeBucket, loyaltyV1Account_universal_d_SortType as SortType, loyaltyV1Account_universal_d_SortDirection as SortDirection, loyaltyV1Account_universal_d_ScalarType as ScalarType, loyaltyV1Account_universal_d_ValueAggregation as ValueAggregation, loyaltyV1Account_universal_d_AggregationType as AggregationType, loyaltyV1Account_universal_d_RangeAggregation as RangeAggregation, loyaltyV1Account_universal_d_ScalarAggregation as ScalarAggregation, loyaltyV1Account_universal_d_GroupByAggregation as GroupByAggregation, loyaltyV1Account_universal_d_GroupByAggregationKindOneOf as GroupByAggregationKindOneOf, loyaltyV1Account_universal_d_SearchDetails as SearchDetails, loyaltyV1Account_universal_d_Mode as Mode, loyaltyV1Account_universal_d_SearchAccountsResponse as SearchAccountsResponse, CursorPagingMetadata$1 as CursorPagingMetadata, loyaltyV1Account_universal_d_AggregationData as AggregationData, loyaltyV1Account_universal_d_ValueAggregationResult as ValueAggregationResult, loyaltyV1Account_universal_d_RangeAggregationResult as RangeAggregationResult, loyaltyV1Account_universal_d_NestedAggregationResults as NestedAggregationResults, loyaltyV1Account_universal_d_NestedAggregationResultsResultOneOf as NestedAggregationResultsResultOneOf, loyaltyV1Account_universal_d_ValueResults as ValueResults, loyaltyV1Account_universal_d_RangeResults as RangeResults, loyaltyV1Account_universal_d_ScalarResult as ScalarResult, loyaltyV1Account_universal_d_NestedValueAggregationResult as NestedValueAggregationResult, loyaltyV1Account_universal_d_GroupByValueResults as GroupByValueResults, loyaltyV1Account_universal_d_AggregationResults as AggregationResults, loyaltyV1Account_universal_d_AggregationResultsResultOneOf as AggregationResultsResultOneOf, loyaltyV1Account_universal_d_CountAccountsRequest as CountAccountsRequest, loyaltyV1Account_universal_d_CountAccountsResponse as CountAccountsResponse, loyaltyV1Account_universal_d_GetTransactionRequest as GetTransactionRequest, loyaltyV1Account_universal_d_GetTransactionResponse as GetTransactionResponse, loyaltyV1Account_universal_d_Transaction as Transaction, loyaltyV1Account_universal_d_ListTransactionsRequest as ListTransactionsRequest, loyaltyV1Account_universal_d_ListTransactionsResponse as ListTransactionsResponse, DomainEvent$3 as DomainEvent, DomainEventBodyOneOf$3 as DomainEventBodyOneOf, EntityCreatedEvent$3 as EntityCreatedEvent, EntityUpdatedEvent$3 as EntityUpdatedEvent, EntityDeletedEvent$3 as EntityDeletedEvent, ActionEvent$3 as ActionEvent, Empty$3 as Empty, loyaltyV1Account_universal_d_AccountsMerged as AccountsMerged, TiersRollingUpdate$1 as TiersRollingUpdate, TiersProgramSettingsChanged$1 as TiersProgramSettingsChanged, TiersProgramSettings$1 as TiersProgramSettings, TiersProgramSettingsPeriodOneOf$1 as TiersProgramSettingsPeriodOneOf, Status$2 as Status, TierDefinition$1 as TierDefinition, RollingWindow$1 as RollingWindow, loyaltyV1Account_universal_d_SubscriptionEvent as SubscriptionEvent, loyaltyV1Account_universal_d_SubscriptionEventEventOneOf as SubscriptionEventEventOneOf, loyaltyV1Account_universal_d_SubscriptionCreated as SubscriptionCreated, loyaltyV1Account_universal_d_Subscription as Subscription, loyaltyV1Account_universal_d_BillingReference as BillingReference, loyaltyV1Account_universal_d_ProviderName as ProviderName, loyaltyV1Account_universal_d_Cycle as Cycle, loyaltyV1Account_universal_d_CycleCycleSelectorOneOf as CycleCycleSelectorOneOf, loyaltyV1Account_universal_d_Interval as Interval, loyaltyV1Account_universal_d_IntervalUnit as IntervalUnit, loyaltyV1Account_universal_d_OneTime as OneTime, loyaltyV1Account_universal_d_SubscriptionStatus as SubscriptionStatus, loyaltyV1Account_universal_d_SubscriptionAssigned as SubscriptionAssigned, loyaltyV1Account_universal_d_SubscriptionCancelled as SubscriptionCancelled, loyaltyV1Account_universal_d_CancellationDetails as CancellationDetails, loyaltyV1Account_universal_d_Initiator as Initiator, loyaltyV1Account_universal_d_SubscriptionAutoRenewTurnedOn as SubscriptionAutoRenewTurnedOn, loyaltyV1Account_universal_d_SubscriptionAutoRenewTurnedOff as SubscriptionAutoRenewTurnedOff, loyaltyV1Account_universal_d_SubscriptionUnassigned as SubscriptionUnassigned, loyaltyV1Account_universal_d_UnassignReason as UnassignReason, loyaltyV1Account_universal_d_SubscriptionTransferred as SubscriptionTransferred, loyaltyV1Account_universal_d_RecurringChargeSucceeded as RecurringChargeSucceeded, loyaltyV1Account_universal_d_ContractSwitched as ContractSwitched, loyaltyV1Account_universal_d_ContractSwitchType as ContractSwitchType, loyaltyV1Account_universal_d_ContractSwitchReason as ContractSwitchReason, loyaltyV1Account_universal_d_ProductPriceIncreaseData as ProductPriceIncreaseData, loyaltyV1Account_universal_d_ProductAdjustment as ProductAdjustment, loyaltyV1Account_universal_d_SubscriptionNearEndOfPeriod as SubscriptionNearEndOfPeriod, loyaltyV1Account_universal_d_SubscriptionPendingChange as SubscriptionPendingChange, loyaltyV1Account_universal_d_ContactSyncRequest as ContactSyncRequest, loyaltyV1Account_universal_d_BulkUpsertAccountsRequest as BulkUpsertAccountsRequest, loyaltyV1Account_universal_d_AccountToUpsert as AccountToUpsert, loyaltyV1Account_universal_d_BulkUpsertAccountsResponse as BulkUpsertAccountsResponse, loyaltyV1Account_universal_d_BulkAccountResult as BulkAccountResult, ItemMetadata$2 as ItemMetadata, ApplicationError$2 as ApplicationError, BulkActionMetadata$2 as BulkActionMetadata, loyaltyV1Account_universal_d_createAccount as createAccount, loyaltyV1Account_universal_d_earnPoints as earnPoints, loyaltyV1Account_universal_d_EarnPointsOptions as EarnPointsOptions, loyaltyV1Account_universal_d_adjustPoints as adjustPoints, loyaltyV1Account_universal_d_AdjustPointsOptions as AdjustPointsOptions, loyaltyV1Account_universal_d_RedeemPointsOptions as RedeemPointsOptions, loyaltyV1Account_universal_d_RedeemDeterminedAmountOfPointsOptions as RedeemDeterminedAmountOfPointsOptions, loyaltyV1Account_universal_d_getAccount as getAccount, loyaltyV1Account_universal_d_ListUserAccountsOptions as ListUserAccountsOptions, loyaltyV1Account_universal_d_getProgramTotals as getProgramTotals, loyaltyV1Account_universal_d_getAccountBySecondaryId as getAccountBySecondaryId, loyaltyV1Account_universal_d_GetAccountBySecondaryIdOptions as GetAccountBySecondaryIdOptions, loyaltyV1Account_universal_d_listAccounts as listAccounts, loyaltyV1Account_universal_d_ListAccountsOptions as ListAccountsOptions, loyaltyV1Account_universal_d_SearchAccountsOptions as SearchAccountsOptions, loyaltyV1Account_universal_d_CountAccountsOptions as CountAccountsOptions, loyaltyV1Account_universal_d_getTransaction as getTransaction, loyaltyV1Account_universal_d_listTransactions as listTransactions, loyaltyV1Account_universal_d_ListTransactionsOptions as ListTransactionsOptions, loyaltyV1Account_universal_d_BulkUpsertAccountsOptions as BulkUpsertAccountsOptions, };
    }
    const __debug$3: {
        verboseLogging: {
            on: () => boolean;
            off: () => boolean;
        };
    };
    /**
     * A loyalty coupon is created when a customer redeems their loyalty points for a reward. Creating a loyalty coupon
     * also creates a corresponding "reference" coupon with the [Coupons API](https://dev.wix.com/api/rest/coupons/about-wix-coupons).
     */
    interface LoyaltyCoupon {
        /**
         * Loyalty coupon ID.
         * @readonly
         */
        _id?: string;
        /**
         * [Loyalty account ID](https://dev.wix.com/api/rest/wix-loyalty-program/accounts) of the customer that redeemed points for a coupon.
         * @readonly
         */
        accountId?: string;
        /**
         * [Member ID](https://dev.wix.com/api/rest/members/members/member-object) of the customer that redeemed points for a coupon.
         * @readonly
         */
        memberIdDeprecated?: string;
        /**
         * [Member ID](https://dev.wix.com/api/rest/members/members/member-object) of the customer that redeemed points for a coupon.
         * @readonly
         */
        memberId?: string | null;
        /**
         * Transaction ID for the transaction that created a coupon.
         * @readonly
         */
        transactionId?: string | null;
        /**
         * Reference coupon information for the corresponding [coupon](https://dev.wix.com/api/rest/coupons/about-wix-coupons)
         * that is created along with the loyalty coupon.
         * @readonly
         */
        couponReference?: CouponReference;
        /**
         * Loyalty coupon status.
         *
         * This status relates to the corresponding coupon that is created
         * at the same time as the loyalty coupon and is included in `couponReference`.
         *
         * + `"ACTIVE"`: The reference coupon is active and available to the customer.
         * + `"APPLIED"`: The reference coupon was applied and is no longer available for use.
         * + `"ARCHIVED"`: The reference coupon was deleted.
         * + `"FAILED"`: The reference coupon was created but something went wrong when redeeming points from the loyalty account.
         * + `"PENDING"`: The refence coupon was created but the loyalty points have not been redeemed yet.
         * @readonly
         */
        status?: Status$1;
        /**
         * Name of reward that was redeemed to create this coupon.
         * @readonly
         */
        rewardName?: string;
        /**
         * Revision number, which increments by 1 each time the loyalty coupon is updated.
         *
         * To prevent conflicting changes, the current `revision`` must be passed when updating the loyalty coupon.
         */
        revision?: string | null;
        /**
         * Date and time the loyalty coupon was created.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * Date and time the loyalty coupon was last updated.
         * @readonly
         */
        _updatedDate?: Date;
    }
    interface CouponReference {
        /**
         * Coupon ID.
         * @readonly
         */
        couponId?: string;
        /**
         * Coupon code.
         *
         * Unique code entered by a customer to apply the coupon.
         *
         * Max: 20 characters
         * @readonly
         */
        code?: string;
        /**
         * Name of coupon.
         *
         * Max: 80 characters
         * @readonly
         */
        name?: string | null;
        /**
         * The information to use when creating the coupon.
         * @readonly
         */
        specification?: Specification;
        /**
         * Whether the loyalty coupon is deleted.
         * @readonly
         */
        deleted?: boolean | null;
    }
    interface Specification extends SpecificationTypeDetailsOneOf, SpecificationScopeOrMinSubtotalOneOf {
        /** Fixed price discount. */
        moneyOffAmount?: number;
        /** Discount as a percentage. */
        percentOffRate?: number;
        /** Free shipping. If true, the coupon applies to all items in all `namespaces` in the site. */
        freeShipping?: boolean;
        /** Specific sale price. Currently only supported for coupons with a `stores` `namespace`. */
        fixedPriceAmount?: number;
        /**
         * Free products when making a purchase. `buyXGetY` is an object that specifies `x` and `y` in the
         * following scenario: if a visitor purchases x number of products, they receive y number of products for free. C
         * urrently only supported for coupons with a `stores` `namespace`.
         */
        buyXGetY?: BuyXGetY;
        /**
         * Scope of the coupon. When no scope is defined, the coupon applies to all
         * items in all `namespaces` in the site.
         */
        scope?: Scope;
        /** The coupon is only applicable when the order subtotal is over this amount. */
        minimumSubtotal?: number | null;
        /** Name of coupon. */
        name?: string | null;
        type?: Type;
        /**
         * Whether the coupon is limited to 1 discount per order. If true and a customer pays for multiple items
         * that the coupon applies to, only the lowest priced item is discounted.
         * Coupons with a `bookings` `namespace` are always limited to 1 item.
         */
        limitedToOneItem?: boolean | null;
        /** Whether the coupon also applies to subscriptions. */
        appliesToSubscriptions?: boolean | null;
        /**
         * Specifies the amount of cycles to apply the discount to for a subscription item.
         *
         * Can only be set when `appliesToSubscriptions` is `TRUE` and `specification.scope.namespace` is `pricingPlans`.
         * If `discountedCycleCount` is empty, the coupon applies to all available cycles.
         *
         * Min: `1`
         *
         * Max: `999`
         */
        discountedCycleCount?: number | null;
    }
    /** @oneof */
    interface SpecificationTypeDetailsOneOf {
        /** Fixed price discount. */
        moneyOffAmount?: number;
        /** Discount as a percentage. */
        percentOffRate?: number;
        /** Free shipping. If true, the coupon applies to all items in all `namespaces` in the site. */
        freeShipping?: boolean;
        /** Specific sale price. Currently only supported for coupons with a `stores` `namespace`. */
        fixedPriceAmount?: number;
        /**
         * Free products when making a purchase. `buyXGetY` is an object that specifies `x` and `y` in the
         * following scenario: if a visitor purchases x number of products, they receive y number of products for free. C
         * urrently only supported for coupons with a `stores` `namespace`.
         */
        buyXGetY?: BuyXGetY;
    }
    /** @oneof */
    interface SpecificationScopeOrMinSubtotalOneOf {
        /**
         * Scope of the coupon. When no scope is defined, the coupon applies to all
         * items in all `namespaces` in the site.
         */
        scope?: Scope;
        /** The coupon is only applicable when the order subtotal is over this amount. */
        minimumSubtotal?: number | null;
    }
    enum Type {
        UNKNOWN = "UNKNOWN",
        MONEY_OFF_AMOUNT = "MONEY_OFF_AMOUNT",
        PERCENT_OFF_RATE = "PERCENT_OFF_RATE",
        FREE_SHIPPING = "FREE_SHIPPING",
        FIXED_PRICE_AMOUNT = "FIXED_PRICE_AMOUNT",
        BUY_X_GET_Y = "BUY_X_GET_Y"
    }
    interface BuyXGetY {
        /** Number of purchased items required to receive free items. */
        x?: number;
        /** Number of items received for free if required number of items were purchased. */
        y?: number;
    }
    interface Scope {
        /**
         * Group within a `namespace` for which the coupon is applicable.
         *
         * If no group is specified, the coupon applies to all items in the namespace.
         * `group` is required in some namespaces. See [Scope Values](https://dev.wix.com/api/rest/coupons/coupons/valid-scope-values)
         * for a list of currently supported groups for each namespace.
         */
        name?: string | null;
        /**
         * ID of the specific entity in the group for which the coupon is applicable.
         *
         * If no `entityId` is specified, the coupon applies to all entities in the group. In some cases when a group is specified,
         * an `entityId` is required. See [Scope Values](https://dev.wix.com/api/rest/coupons/coupons/valid-scope-values)
         * for a list of currently supported entities for each namespace and group.
         */
        entityId?: string | null;
        /**
         * Wix application for which the coupon is applicable.
         *
         * One of the following:
         * + `"stores"`
         * + `"bookings"`
         * + `"events"`
         * + `"pricingPlans"`
         */
        namespace?: string;
    }
    enum Status$1 {
        UNKNOWN = "UNKNOWN",
        /** coupon created but points haven't been redeemed yet (ideally coupons should stay in this state for a very short time (seconds/minutes)) */
        PENDING = "PENDING",
        /** coupon is active and can be applied */
        ACTIVE = "ACTIVE",
        /** coupon was already applied and can not be used anymore */
        APPLIED = "APPLIED",
        /** coupon was created but something went wrong when redeeming points from the account */
        FAILED = "FAILED",
        /** reference coupon was deleted */
        ARCHIVED = "ARCHIVED"
    }
    interface RedeemPointsForCouponRequest {
        /** ID of the [loyalty reward](https://dev.wix.com/api/rest/wix-loyalty-program/rewards) to redeem. */
        rewardId: string;
        /** ID of the [loyalty account](https://dev.wix.com/api/rest/wix-loyalty-program/accounts) of the customer redeeming points. */
        loyaltyAccountId: string;
    }
    interface RedeemPointsForCouponResponse {
        /** Created loyalty coupon. */
        coupon?: LoyaltyCoupon;
    }
    interface RedeemCurrentMemberPointsForCouponRequest {
        /** ID of the [loyalty reward](https://dev.wix.com/api/rest/wix-loyalty-program/rewards) to redeem. */
        rewardId: string;
    }
    interface RedeemCurrentMemberPointsForCouponResponse {
        /** Created loyalty coupon. */
        coupon?: LoyaltyCoupon;
    }
    interface RedeemMemberPointsForDiscountAmountCouponRequest {
        /** ID of the [loyalty reward](https://dev.wix.com/api/rest/wix-loyalty-program/rewards) to redeem. */
        rewardId: string;
        loyaltyAccountId: string;
        pointsToRedeem: number;
        specification: Specification;
    }
    interface RedeemMemberPointsForDiscountAmountCouponResponse {
        /** Created loyalty coupon. */
        coupon?: LoyaltyCoupon;
        /** Transaction id of the coupon application */
        transactionId?: string;
    }
    interface GetLoyaltyCouponRequest {
        /** ID of the loyalty coupon to retrieve. */
        loyaltyCouponId: string;
    }
    interface GetLoyaltyCouponResponse {
        /** Retrieved loyalty coupon. */
        loyaltyCoupon?: LoyaltyCoupon;
    }
    interface GetCurrentMemberCouponsRequest {
    }
    interface GetCurrentMemberCouponsResponse {
        /** Retrieved loyalty coupons. */
        loyaltyCoupons?: LoyaltyCoupon[];
    }
    interface QueryLoyaltyCouponRequest {
        /** WQL expression */
        query: QueryV2;
    }
    interface QueryV2 extends QueryV2PagingMethodOneOf {
        /** Paging options to limit and skip the number of items. */
        paging?: Paging;
        /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
        cursorPaging?: CursorPaging$1;
        /**
         * Filter object in the following format:
         * `"filter" : {
         * "fieldName1": "value1",
         * "fieldName2":{"$operator":"value2"}
         * }`
         * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
         */
        filter?: Record<string, any> | null;
        /**
         * Sort object in the following format:
         * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
         */
        sort?: Sorting$1[];
        /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
        fields?: string[];
        /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
        fieldsets?: string[];
    }
    /** @oneof */
    interface QueryV2PagingMethodOneOf {
        /** Paging options to limit and skip the number of items. */
        paging?: Paging;
        /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
        cursorPaging?: CursorPaging$1;
    }
    interface Sorting$1 {
        /** Name of the field to sort by. */
        fieldName?: string;
        /** Sort order. */
        order?: SortOrder$1;
    }
    enum SortOrder$1 {
        ASC = "ASC",
        DESC = "DESC"
    }
    interface Paging {
        /** Number of items to load. */
        limit?: number | null;
        /** Number of items to skip in the current sort order. */
        offset?: number | null;
    }
    interface CursorPaging$1 {
        /** Number of items to load. */
        limit?: number | null;
        /**
         * Pointer to the next or previous page in the list of results.
         *
         * You can get the relevant cursor token
         * from the `pagingMetadata` object in the previous call's response.
         * Not relevant for the first request.
         */
        cursor?: string | null;
    }
    interface QueryLoyaltyCouponResponse {
        /** Retrieved loyalty coupons. */
        loyaltyCoupons?: LoyaltyCoupon[];
        /** Metadata. */
        metadata?: PagingMetadataV2$1;
    }
    interface PagingMetadataV2$1 {
        /** Number of items returned in the response. */
        count?: number | null;
        /** Offset that was requested. */
        offset?: number | null;
        /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
        total?: number | null;
        /** Flag that indicates the server failed to calculate the `total` field. */
        tooManyToCount?: boolean | null;
        /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
        cursors?: Cursors$1;
    }
    interface Cursors$1 {
        /** Cursor pointing to next page in the list of results. */
        next?: string | null;
        /** Cursor pointing to previous page in the list of results. */
        prev?: string | null;
    }
    interface QueryCouponTemplateRequest {
        /** WQL expression */
        query: Query;
    }
    interface Query {
        /** Optional pagination parameters */
        paging?: V2Paging;
        /** Filter string (e.g., when {"expired":"true"}, expired coupons will be returned). */
        filter?: string | null;
        /** Sort string. */
        sort?: string | null;
    }
    interface V2Paging {
        /** Number of items to load. */
        limit?: number | null;
        /** Offset since the beginning of the collection. */
        offset?: number | null;
    }
    interface QueryCouponTemplateResponse {
        /** The retrieved CouponReferences */
        couponReferences?: CouponReference[];
        totalResults?: number | null;
    }
    interface DeleteLoyaltyCouponRequest {
        /** ID of the loyalty coupon to delete. */
        _id: string;
        /**
         * Revision number, which increments by 1 each time the loyalty coupon is updated.
         *
         * To prevent conflicting changes, the current `revision`` must be passed when updating the loyalty coupon.
         */
        revision?: string;
    }
    interface DeleteLoyaltyCouponResponse {
    }
    interface DomainEvent$2 extends DomainEventBodyOneOf$2 {
        createdEvent?: EntityCreatedEvent$2;
        updatedEvent?: EntityUpdatedEvent$2;
        deletedEvent?: EntityDeletedEvent$2;
        actionEvent?: ActionEvent$2;
        /** random GUID so clients can tell if event was already handled */
        _id?: string;
        /**
         * Assumes actions are also always typed to an entity_type
         * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
         */
        entityFqdn?: string;
        /**
         * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
         * This is although the created/updated/deleted notion is duplication of the oneof types
         * Example: created/updated/deleted/started/completed/email_opened
         */
        slug?: string;
        /**
         * Assuming that all messages including Actions have id
         * Example: The id of the specific order, the id of a specific campaign
         */
        entityId?: string;
        /** The time of the event. Useful if there was a delay in dispatching */
        eventTime?: Date;
        /**
         * A field that should be set if this event was triggered by an anonymize request.
         * For example you must set it to true when sending an event as a result of a GDPR right to be forgotten request.
         * NOTE: This field is not relevant for `EntityCreatedEvent` but is located here for better ergonomics of consumers.
         */
        triggeredByAnonymizeRequest?: boolean | null;
        /** If present, indicates the action that triggered the event. */
        originatedFrom?: string | null;
        /**
         * A sequence number defining the order of updates to the underlying entity.
         * For example, given that some entity was updated at 16:00 and than again at 16:01,
         * it is guaranteed that the sequence number of the second update is strictly higher than the first.
         * As the consumer, you can use this value to ensure that you handle messages in the correct order.
         * To do so, you will need to persist this number on your end, and compare the sequence number from the
         * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
         */
        entityEventSequence?: string | null;
    }
    /** @oneof */
    interface DomainEventBodyOneOf$2 {
        createdEvent?: EntityCreatedEvent$2;
        updatedEvent?: EntityUpdatedEvent$2;
        deletedEvent?: EntityDeletedEvent$2;
        actionEvent?: ActionEvent$2;
    }
    interface EntityCreatedEvent$2 {
        entityAsJson?: string;
    }
    interface EntityUpdatedEvent$2 {
        /**
         * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
         * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
         * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
         */
        currentEntityAsJson?: string;
    }
    interface EntityDeletedEvent$2 {
    }
    interface ActionEvent$2 {
        bodyAsJson?: string;
    }
    interface Empty$2 {
    }
    /**
     * Redeems a customer's loyalty points for a loyalty reward and creates a loyalty coupon.
     *
     * Creating a loyalty coupon also creates a corresponding "reference" coupon with the [Coupons API](https://dev.wix.com/api/rest/coupons/about-wix-coupons).
     * The customer receives the reference coupon, which they can apply to their order. The loyalty coupon and its corresponding reference coupon
     * are linked and the loyalty coupon's `status` reflects the current state of the reference coupon.
     *
     * Check which loyalty rewards a site has available with [List Rewards](https://dev.wix.com/api/rest/wix-loyalty-program/rewards/list-rewards).
     *
     * This function is not a universal function and runs only on the backend.
     * @param rewardId - ID of the [loyalty reward](https://dev.wix.com/api/rest/wix-loyalty-program/rewards) to redeem.
     * @public
     * @documentationMaturity preview
     * @requiredField options
     * @requiredField options.loyaltyAccountId
     * @requiredField rewardId
     * @adminMethod
     */
    function redeemPointsForCoupon(rewardId: string, options: RedeemPointsForCouponOptions): Promise<RedeemPointsForCouponResponse>;
    interface RedeemPointsForCouponOptions {
        /** ID of the [loyalty account](https://dev.wix.com/api/rest/wix-loyalty-program/accounts) of the customer redeeming points. */
        loyaltyAccountId: string;
    }
    /**
     * Redeems a current customer's loyalty points for a loyalty reward and creates a loyalty coupon.
     *
     * Creating a loyalty coupon also creates a corresponding "reference" coupon with the [Coupons API](https://dev.wix.com/api/rest/coupons/about-wix-coupons).
     * The customer receives the reference coupon, which they can apply to their order. The loyalty coupon and its corresponding reference coupon
     * are linked and the loyalty coupon's `status` reflects the current state of the reference coupon.
     *
     * Check which loyalty rewards a site has available with [List Rewards](https://dev.wix.com/api/rest/wix-loyalty-program/rewards/list-rewards).
     * @param rewardId - ID of the [loyalty reward](https://dev.wix.com/api/rest/wix-loyalty-program/rewards) to redeem.
     * @public
     * @documentationMaturity preview
     * @requiredField rewardId
     */
    function redeemCurrentMemberPointsForCoupon(rewardId: string): Promise<RedeemCurrentMemberPointsForCouponResponse>;
    interface RedeemMemberPointsForDiscountAmountCouponOptions {
        loyaltyAccountId: string;
        pointsToRedeem: number;
        specification: Specification;
    }
    /**
     * Retrieves a loyalty coupon.
     *
     * This function is not a universal function and runs only on the backend.
     * @param loyaltyCouponId - ID of the loyalty coupon to retrieve.
     * @public
     * @documentationMaturity preview
     * @requiredField loyaltyCouponId
     * @adminMethod
     */
    function getLoyaltyCoupon(loyaltyCouponId: string): Promise<GetLoyaltyCouponResponse>;
    /**
     * Retrieves the loyalty coupons for the currently logged-in member.
     * @public
     * @documentationMaturity preview
     */
    function getCurrentMemberCoupons(): Promise<GetCurrentMemberCouponsResponse>;
    /**
     * Retrieves a list of loyalty coupons, given the provided paging, filtering, and sorting.
     *
     * This function is not a universal function and runs only on the backend.
     * @param query - WQL expression
     * @public
     * @documentationMaturity preview
     * @requiredField query
     * @adminMethod
     */
    function queryLoyaltyCoupons(query: QueryV2): Promise<QueryLoyaltyCouponResponse>;
    /**
     * Deletes a loyalty coupon.
     *
     * The deletion of a loyalty coupon does not impact the functionality of the corresponding coupon itself.
     *
     * This function is not a universal function and runs only on the backend.
     * @param _id - ID of the loyalty coupon to delete.
     * @param revision - Revision number, which increments by 1 each time the loyalty coupon is updated.
     *
     * To prevent conflicting changes, the current `revision`` must be passed when updating the loyalty coupon.
     * @public
     * @documentationMaturity preview
     * @requiredField _id
     * @requiredField revision
     * @adminMethod
     */
    function deleteLoyaltyCoupon(_id: string, revision: string): Promise<void>;
    type loyaltyV1Coupon_universal_d_LoyaltyCoupon = LoyaltyCoupon;
    type loyaltyV1Coupon_universal_d_CouponReference = CouponReference;
    type loyaltyV1Coupon_universal_d_Specification = Specification;
    type loyaltyV1Coupon_universal_d_SpecificationTypeDetailsOneOf = SpecificationTypeDetailsOneOf;
    type loyaltyV1Coupon_universal_d_SpecificationScopeOrMinSubtotalOneOf = SpecificationScopeOrMinSubtotalOneOf;
    type loyaltyV1Coupon_universal_d_Type = Type;
    const loyaltyV1Coupon_universal_d_Type: typeof Type;
    type loyaltyV1Coupon_universal_d_BuyXGetY = BuyXGetY;
    type loyaltyV1Coupon_universal_d_Scope = Scope;
    type loyaltyV1Coupon_universal_d_RedeemPointsForCouponRequest = RedeemPointsForCouponRequest;
    type loyaltyV1Coupon_universal_d_RedeemPointsForCouponResponse = RedeemPointsForCouponResponse;
    type loyaltyV1Coupon_universal_d_RedeemCurrentMemberPointsForCouponRequest = RedeemCurrentMemberPointsForCouponRequest;
    type loyaltyV1Coupon_universal_d_RedeemCurrentMemberPointsForCouponResponse = RedeemCurrentMemberPointsForCouponResponse;
    type loyaltyV1Coupon_universal_d_RedeemMemberPointsForDiscountAmountCouponRequest = RedeemMemberPointsForDiscountAmountCouponRequest;
    type loyaltyV1Coupon_universal_d_RedeemMemberPointsForDiscountAmountCouponResponse = RedeemMemberPointsForDiscountAmountCouponResponse;
    type loyaltyV1Coupon_universal_d_GetLoyaltyCouponRequest = GetLoyaltyCouponRequest;
    type loyaltyV1Coupon_universal_d_GetLoyaltyCouponResponse = GetLoyaltyCouponResponse;
    type loyaltyV1Coupon_universal_d_GetCurrentMemberCouponsRequest = GetCurrentMemberCouponsRequest;
    type loyaltyV1Coupon_universal_d_GetCurrentMemberCouponsResponse = GetCurrentMemberCouponsResponse;
    type loyaltyV1Coupon_universal_d_QueryLoyaltyCouponRequest = QueryLoyaltyCouponRequest;
    type loyaltyV1Coupon_universal_d_QueryV2 = QueryV2;
    type loyaltyV1Coupon_universal_d_QueryV2PagingMethodOneOf = QueryV2PagingMethodOneOf;
    type loyaltyV1Coupon_universal_d_Paging = Paging;
    type loyaltyV1Coupon_universal_d_QueryLoyaltyCouponResponse = QueryLoyaltyCouponResponse;
    type loyaltyV1Coupon_universal_d_QueryCouponTemplateRequest = QueryCouponTemplateRequest;
    type loyaltyV1Coupon_universal_d_Query = Query;
    type loyaltyV1Coupon_universal_d_V2Paging = V2Paging;
    type loyaltyV1Coupon_universal_d_QueryCouponTemplateResponse = QueryCouponTemplateResponse;
    type loyaltyV1Coupon_universal_d_DeleteLoyaltyCouponRequest = DeleteLoyaltyCouponRequest;
    type loyaltyV1Coupon_universal_d_DeleteLoyaltyCouponResponse = DeleteLoyaltyCouponResponse;
    const loyaltyV1Coupon_universal_d_redeemPointsForCoupon: typeof redeemPointsForCoupon;
    type loyaltyV1Coupon_universal_d_RedeemPointsForCouponOptions = RedeemPointsForCouponOptions;
    const loyaltyV1Coupon_universal_d_redeemCurrentMemberPointsForCoupon: typeof redeemCurrentMemberPointsForCoupon;
    type loyaltyV1Coupon_universal_d_RedeemMemberPointsForDiscountAmountCouponOptions = RedeemMemberPointsForDiscountAmountCouponOptions;
    const loyaltyV1Coupon_universal_d_getLoyaltyCoupon: typeof getLoyaltyCoupon;
    const loyaltyV1Coupon_universal_d_getCurrentMemberCoupons: typeof getCurrentMemberCoupons;
    const loyaltyV1Coupon_universal_d_queryLoyaltyCoupons: typeof queryLoyaltyCoupons;
    const loyaltyV1Coupon_universal_d_deleteLoyaltyCoupon: typeof deleteLoyaltyCoupon;
    namespace loyaltyV1Coupon_universal_d {
        export { __debug$3 as __debug, loyaltyV1Coupon_universal_d_LoyaltyCoupon as LoyaltyCoupon, loyaltyV1Coupon_universal_d_CouponReference as CouponReference, loyaltyV1Coupon_universal_d_Specification as Specification, loyaltyV1Coupon_universal_d_SpecificationTypeDetailsOneOf as SpecificationTypeDetailsOneOf, loyaltyV1Coupon_universal_d_SpecificationScopeOrMinSubtotalOneOf as SpecificationScopeOrMinSubtotalOneOf, loyaltyV1Coupon_universal_d_Type as Type, loyaltyV1Coupon_universal_d_BuyXGetY as BuyXGetY, loyaltyV1Coupon_universal_d_Scope as Scope, Status$1 as Status, loyaltyV1Coupon_universal_d_RedeemPointsForCouponRequest as RedeemPointsForCouponRequest, loyaltyV1Coupon_universal_d_RedeemPointsForCouponResponse as RedeemPointsForCouponResponse, loyaltyV1Coupon_universal_d_RedeemCurrentMemberPointsForCouponRequest as RedeemCurrentMemberPointsForCouponRequest, loyaltyV1Coupon_universal_d_RedeemCurrentMemberPointsForCouponResponse as RedeemCurrentMemberPointsForCouponResponse, loyaltyV1Coupon_universal_d_RedeemMemberPointsForDiscountAmountCouponRequest as RedeemMemberPointsForDiscountAmountCouponRequest, loyaltyV1Coupon_universal_d_RedeemMemberPointsForDiscountAmountCouponResponse as RedeemMemberPointsForDiscountAmountCouponResponse, loyaltyV1Coupon_universal_d_GetLoyaltyCouponRequest as GetLoyaltyCouponRequest, loyaltyV1Coupon_universal_d_GetLoyaltyCouponResponse as GetLoyaltyCouponResponse, loyaltyV1Coupon_universal_d_GetCurrentMemberCouponsRequest as GetCurrentMemberCouponsRequest, loyaltyV1Coupon_universal_d_GetCurrentMemberCouponsResponse as GetCurrentMemberCouponsResponse, loyaltyV1Coupon_universal_d_QueryLoyaltyCouponRequest as QueryLoyaltyCouponRequest, loyaltyV1Coupon_universal_d_QueryV2 as QueryV2, loyaltyV1Coupon_universal_d_QueryV2PagingMethodOneOf as QueryV2PagingMethodOneOf, Sorting$1 as Sorting, SortOrder$1 as SortOrder, loyaltyV1Coupon_universal_d_Paging as Paging, CursorPaging$1 as CursorPaging, loyaltyV1Coupon_universal_d_QueryLoyaltyCouponResponse as QueryLoyaltyCouponResponse, PagingMetadataV2$1 as PagingMetadataV2, Cursors$1 as Cursors, loyaltyV1Coupon_universal_d_QueryCouponTemplateRequest as QueryCouponTemplateRequest, loyaltyV1Coupon_universal_d_Query as Query, loyaltyV1Coupon_universal_d_V2Paging as V2Paging, loyaltyV1Coupon_universal_d_QueryCouponTemplateResponse as QueryCouponTemplateResponse, loyaltyV1Coupon_universal_d_DeleteLoyaltyCouponRequest as DeleteLoyaltyCouponRequest, loyaltyV1Coupon_universal_d_DeleteLoyaltyCouponResponse as DeleteLoyaltyCouponResponse, DomainEvent$2 as DomainEvent, DomainEventBodyOneOf$2 as DomainEventBodyOneOf, EntityCreatedEvent$2 as EntityCreatedEvent, EntityUpdatedEvent$2 as EntityUpdatedEvent, EntityDeletedEvent$2 as EntityDeletedEvent, ActionEvent$2 as ActionEvent, Empty$2 as Empty, loyaltyV1Coupon_universal_d_redeemPointsForCoupon as redeemPointsForCoupon, loyaltyV1Coupon_universal_d_RedeemPointsForCouponOptions as RedeemPointsForCouponOptions, loyaltyV1Coupon_universal_d_redeemCurrentMemberPointsForCoupon as redeemCurrentMemberPointsForCoupon, loyaltyV1Coupon_universal_d_RedeemMemberPointsForDiscountAmountCouponOptions as RedeemMemberPointsForDiscountAmountCouponOptions, loyaltyV1Coupon_universal_d_getLoyaltyCoupon as getLoyaltyCoupon, loyaltyV1Coupon_universal_d_getCurrentMemberCoupons as getCurrentMemberCoupons, loyaltyV1Coupon_universal_d_queryLoyaltyCoupons as queryLoyaltyCoupons, loyaltyV1Coupon_universal_d_deleteLoyaltyCoupon as deleteLoyaltyCoupon, };
    }
    const __debug$2: {
        verboseLogging: {
            on: () => boolean;
            off: () => boolean;
        };
    };
    /**
     * A loyalty program allows sites to maintain customer reward accounts. Site owners can create a
     * loyalty program to increase customer retention. Read more about the loyalty program in
     * [this overview](https://support.wix.com/en/article/wix-loyalty-program-an-overview).
     */
    interface LoyaltyProgram {
        /** Program name. */
        name?: string | null;
        /** Information about the program's collectible entity. */
        pointDefinition?: PointDefinition;
        /**
         * Program status. Customers can only earn or redeem points while the program is `"ACTIVE"`.
         *
         * Default: `"DRAFT"`
         * @readonly
         */
        status?: ProgramStatus;
        /**
         * Date and time the program was created.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * Date and time the program was updated.
         * @readonly
         */
        _updatedDate?: Date;
        /**
         * Set to true if user has required plan to activate program
         * @readonly
         */
        isPremium?: boolean;
    }
    interface PointDefinition {
        /**
         * Display name for the program's collectible unit. It's recommended to use the plural, for example
         * `"Stars"`. In contrast to a custom name, the default `"Points"` name is translated and adjusted to singular based
         * on circumstances.
         *
         * Default: `"Points"`
         *
         * Max: 20 characters
         */
        customName?: string | null;
        /** Image URL. See [Image]($w/image/introduction) for more information on URL formats for images. */
        icon?: string;
    }
    enum ProgramStatus {
        UNKNOWN = "UNKNOWN",
        /** initial program status (program was created but was not enabled yet) */
        DRAFT = "DRAFT",
        /** program is active */
        ACTIVE = "ACTIVE",
        /** program was manually disabled by the user (this action can be reverted, meaning user can set it to be active again) */
        PAUSED = "PAUSED"
    }
    interface GetLoyaltyProgramRequest {
    }
    interface GetLoyaltyProgramResponse {
        /** Retrieved loyalty program. */
        loyaltyProgram?: LoyaltyProgram;
    }
    interface BulkGetLoyaltyProgramRequest {
        /** Metasite IDs. */
        metaSiteIds?: string[];
    }
    interface BulkGetLoyaltyProgramResponse {
        /** Retrieved loyalty programs. */
        programInSites?: ProgramInSite[];
    }
    interface ProgramInSite {
        /** Metasite ID. */
        metaSiteId?: string;
        /** Loyalty program. */
        loyaltyProgram?: LoyaltyProgram;
    }
    interface UpdateLoyaltyProgramRequest {
        /** Loyalty program fields to update. */
        loyaltyProgram: LoyaltyProgram;
    }
    interface UpdateLoyaltyProgramResponse {
        /** Updated loyalty program. */
        loyaltyProgram?: LoyaltyProgram;
    }
    interface ActivateLoyaltyProgramRequest {
    }
    interface ActivateLoyaltyProgramResponse {
        /** Activated loyalty program. */
        loyaltyProgram?: LoyaltyProgram;
    }
    interface PauseLoyaltyProgramRequest {
    }
    interface PauseLoyaltyProgramResponse {
        /** Paused loyalty program. */
        loyaltyProgram?: LoyaltyProgram;
    }
    interface GetLoyaltyProgramDescriptionRequest {
        /** List of description fields to retrieve. Supported values: `description`, `updatedDate`. */
        fields?: string[];
    }
    interface GetLoyaltyProgramDescriptionResponse {
        /** Retrieved loyalty program description. */
        description?: string | null;
        /** Date and time of the latest description update. */
        _updatedDate?: Date;
    }
    interface UpdateLoyaltyProgramDescriptionRequest {
        /** Loyalty program description to update. */
        description?: string;
    }
    interface UpdateLoyaltyProgramDescriptionResponse {
    }
    interface LoyaltyProgramDescriptionUpdated {
    }
    interface GetLoyaltyProgramPremiumFeaturesRequest {
    }
    interface GetLoyaltyProgramPremiumFeaturesResponse {
        /**
         * Set to true if user has loyalty program feature
         * @readonly
         */
        loyaltyProgram?: boolean;
    }
    interface MetaSiteSpecialEvent extends MetaSiteSpecialEventPayloadOneOf {
        siteCreated?: SiteCreated;
        siteTransferred?: SiteTransferred;
        siteDeleted?: SiteDeleted;
        siteUndeleted?: SiteUndeleted;
        sitePublished?: SitePublished;
        siteUnpublished?: SiteUnpublished;
        siteMarkedAsTemplate?: SiteMarkedAsTemplate;
        siteMarkedAsWixSite?: SiteMarkedAsWixSite;
        serviceProvisioned?: ServiceProvisioned;
        serviceRemoved?: ServiceRemoved;
        siteRenamedPayload?: SiteRenamed;
        hardDeleted?: SiteHardDeleted;
        namespaceChanged?: NamespaceChanged;
        studioAssigned?: StudioAssigned;
        studioUnassigned?: StudioUnassigned;
        metaSiteId?: string;
        version?: string;
        timestamp?: string;
        assets?: Asset[];
    }
    /** @oneof */
    interface MetaSiteSpecialEventPayloadOneOf {
        siteCreated?: SiteCreated;
        siteTransferred?: SiteTransferred;
        siteDeleted?: SiteDeleted;
        siteUndeleted?: SiteUndeleted;
        sitePublished?: SitePublished;
        siteUnpublished?: SiteUnpublished;
        siteMarkedAsTemplate?: SiteMarkedAsTemplate;
        siteMarkedAsWixSite?: SiteMarkedAsWixSite;
        serviceProvisioned?: ServiceProvisioned;
        serviceRemoved?: ServiceRemoved;
        siteRenamedPayload?: SiteRenamed;
        hardDeleted?: SiteHardDeleted;
        namespaceChanged?: NamespaceChanged;
        studioAssigned?: StudioAssigned;
        studioUnassigned?: StudioUnassigned;
    }
    interface Asset {
        appDefId?: string;
        instanceId?: string;
        state?: State;
    }
    enum State {
        UNKNOWN = "UNKNOWN",
        ENABLED = "ENABLED",
        DISABLED = "DISABLED",
        PENDING = "PENDING",
        DEMO = "DEMO"
    }
    interface SiteCreated {
        originTemplateId?: string;
        ownerId?: string;
        context?: SiteCreatedContext;
        /**
         * A meta site id from which this site was created.
         *
         * In case of a creation from a template it's a template id.
         * In case of a site duplication ("Save As" in dashboard or duplicate in UM) it's an id of a source site.
         */
        originMetaSiteId?: string | null;
        siteName?: string;
        namespace?: Namespace;
    }
    enum SiteCreatedContext {
        /** A valid option, we don't expose all reasons why site might be created. */
        OTHER = "OTHER",
        /** A meta site was created from template. */
        FROM_TEMPLATE = "FROM_TEMPLATE",
        /** A meta site was created by copying of the transfferred meta site. */
        DUPLICATE_BY_SITE_TRANSFER = "DUPLICATE_BY_SITE_TRANSFER",
        /** A copy of existing meta site. */
        DUPLICATE = "DUPLICATE",
        /** A meta site was created as a transfferred site (copy of the original), old flow, should die soon. */
        OLD_SITE_TRANSFER = "OLD_SITE_TRANSFER",
        /** deprecated A meta site was created for Flash editor. */
        FLASH = "FLASH"
    }
    enum Namespace {
        UNKNOWN_NAMESPACE = "UNKNOWN_NAMESPACE",
        /** Default namespace for UGC sites. MetaSites with this namespace will be shown in a user's site list by default. */
        WIX = "WIX",
        /** ShoutOut stand alone product. These are siteless (no actual Wix site, no HtmlWeb). MetaSites with this namespace will *not* be shown in a user's site list by default. */
        SHOUT_OUT = "SHOUT_OUT",
        /** MetaSites created by the Albums product, they appear as part of the Albums app. MetaSites with this namespace will *not* be shown in a user's site list by default. */
        ALBUMS = "ALBUMS",
        /** Part of the WixStores migration flow, a user tries to migrate and gets this site to view and if the user likes it then stores removes this namespace and deletes the old site with the old stores. MetaSites with this namespace will *not* be shown in a user's site list by default. */
        WIX_STORES_TEST_DRIVE = "WIX_STORES_TEST_DRIVE",
        /** Hotels standalone (siteless). MetaSites with this namespace will *not* be shown in a user's site list by default. */
        HOTELS = "HOTELS",
        /** Clubs siteless MetaSites, a club without a wix website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
        CLUBS = "CLUBS",
        /** A partially created ADI website. MetaSites with this namespace will *not* be shown in a user's site list by default. */
        ONBOARDING_DRAFT = "ONBOARDING_DRAFT",
        /** AppBuilder for AppStudio / shmite (c). MetaSites with this namespace will *not* be shown in a user's site list by default. */
        DEV_SITE = "DEV_SITE",
        /** LogoMaker websites offered to the user after logo purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
        LOGOS = "LOGOS",
        /** VideoMaker websites offered to the user after video purchase. MetaSites with this namespace will *not* be shown in a user's site list by default. */
        VIDEO_MAKER = "VIDEO_MAKER",
        /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
        PARTNER_DASHBOARD = "PARTNER_DASHBOARD",
        /** MetaSites with this namespace will *not* be shown in a user's site list by default. */
        DEV_CENTER_COMPANY = "DEV_CENTER_COMPANY",
        /**
         * A draft created by HTML editor on open. Upon "first save" it will be moved to be of WIX domain.
         *
         * Meta site with this namespace will *not* be shown in a user's site list by default.
         */
        HTML_DRAFT = "HTML_DRAFT",
        /**
         * the user-journey for Fitness users who want to start from managing their business instead of designing their website.
         * Will be accessible from Site List and will not have a website app.
         * Once the user attaches a site, the site will become a regular wixsite.
         */
        SITELESS_BUSINESS = "SITELESS_BUSINESS",
        /** Belongs to "strategic products" company. Supports new product in the creator's economy space. */
        CREATOR_ECONOMY = "CREATOR_ECONOMY",
        /** It is to be used in the Business First efforts. */
        DASHBOARD_FIRST = "DASHBOARD_FIRST",
        /** Bookings business flow with no site. */
        ANYWHERE = "ANYWHERE",
        /** Namespace for Headless Backoffice with no editor */
        HEADLESS = "HEADLESS",
        /**
         * Namespace for master site that will exist in parent account that will be referenced by subaccounts
         * The site will be used for account level CSM feature for enterprise
         */
        ACCOUNT_MASTER_CMS = "ACCOUNT_MASTER_CMS"
    }
    /** Site transferred to another user. */
    interface SiteTransferred {
        /** A previous owner id (user that transfers meta site). */
        oldOwnerId?: string;
        /** A new owner id (user that accepts meta site). */
        newOwnerId?: string;
    }
    /** Soft deletion of the meta site. Could be restored. */
    interface SiteDeleted {
        deleteContext?: DeleteContext;
    }
    interface DeleteContext {
        dateDeleted?: Date;
        deleteStatus?: DeleteStatus;
        deleteOrigin?: string;
        initiatorId?: string | null;
    }
    enum DeleteStatus {
        UNKNOWN = "UNKNOWN",
        TRASH = "TRASH",
        DELETED = "DELETED",
        PENDING_PURGE = "PENDING_PURGE"
    }
    /** Restoration of the meta site. */
    interface SiteUndeleted {
    }
    /** First publish of a meta site. Or subsequent publish after unpublish. */
    interface SitePublished {
    }
    interface SiteUnpublished {
        urls?: string[];
    }
    interface SiteMarkedAsTemplate {
    }
    interface SiteMarkedAsWixSite {
    }
    interface ServiceProvisioned {
        /** Either UUID or EmbeddedServiceType. */
        appDefId?: string;
        /** Not only UUID. Something here could be something weird. */
        instanceId?: string;
        originInstanceId?: string;
        version?: string | null;
    }
    interface ServiceRemoved {
        appDefId?: string;
        instanceId?: string;
        version?: string | null;
    }
    /** Rename of the site. Meaning, free public url has been changed as well. */
    interface SiteRenamed {
        newSiteName?: string;
        oldSiteName?: string;
    }
    /**
     * Hard deletion of the meta site.
     *
     * Could not be restored. Therefore it's desirable to cleanup data.
     */
    interface SiteHardDeleted {
        deleteContext?: DeleteContext;
    }
    interface NamespaceChanged {
        oldNamespace?: Namespace;
        newNamespace?: Namespace;
    }
    /** Assigned Studio editor */
    interface StudioAssigned {
    }
    /** Unassigned Studio editor */
    interface StudioUnassigned {
    }
    interface Empty$1 {
    }
    interface DomainEvent$1 extends DomainEventBodyOneOf$1 {
        createdEvent?: EntityCreatedEvent$1;
        updatedEvent?: EntityUpdatedEvent$1;
        deletedEvent?: EntityDeletedEvent$1;
        actionEvent?: ActionEvent$1;
        /**
         * Unique event ID.
         * Allows clients to ignore duplicate webhooks.
         */
        _id?: string;
        /**
         * Assumes actions are also always typed to an entity_type
         * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
         */
        entityFqdn?: string;
        /**
         * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
         * This is although the created/updated/deleted notion is duplication of the oneof types
         * Example: created/updated/deleted/started/completed/email_opened
         */
        slug?: string;
        /** ID of the entity associated with the event. */
        entityId?: string;
        /** Event timestamp. */
        eventTime?: Date;
        /**
         * Whether the event was triggered as a result of a privacy regulation application
         * (for example, GDPR).
         */
        triggeredByAnonymizeRequest?: boolean | null;
        /** If present, indicates the action that triggered the event. */
        originatedFrom?: string | null;
        /**
         * A sequence number defining the order of updates to the underlying entity.
         * For example, given that some entity was updated at 16:00 and than again at 16:01,
         * it is guaranteed that the sequence number of the second update is strictly higher than the first.
         * As the consumer, you can use this value to ensure that you handle messages in the correct order.
         * To do so, you will need to persist this number on your end, and compare the sequence number from the
         * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
         */
        entityEventSequence?: string | null;
    }
    /** @oneof */
    interface DomainEventBodyOneOf$1 {
        createdEvent?: EntityCreatedEvent$1;
        updatedEvent?: EntityUpdatedEvent$1;
        deletedEvent?: EntityDeletedEvent$1;
        actionEvent?: ActionEvent$1;
    }
    interface EntityCreatedEvent$1 {
        entityAsJson?: string;
    }
    interface EntityUpdatedEvent$1 {
        /**
         * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
         * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
         * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
         */
        currentEntityAsJson?: string;
    }
    interface EntityDeletedEvent$1 {
    }
    interface ActionEvent$1 {
        bodyAsJson?: string;
    }
    /**
     * Retrieves the site's loyalty program.
     *
     * The `getLoyaltyProgram()` function returns a Promise that resolves to the site's loyalty program.
     * @public
     * @documentationMaturity preview
     */
    function getLoyaltyProgram(): Promise<GetLoyaltyProgramResponse>;
    interface BulkGetLoyaltyProgramOptions {
        /** Metasite IDs. */
        metaSiteIds?: string[];
    }
    /**
     * Updates the site's loyalty program.
     *
     * The `updateLoyaltyProgram()` function returns a Promise that resolves when the loyalty program is updated.
     *
     * With the `updateLoyaltyProgram()` function you can update the name of the loyalty program and the details of the collectible points unit. To activate the loyalty program use the [`activateLoyaltyProgram()`](wix-loyalty-v2/programs/activateloyaltyprogram) function.
     *
     * >**Note:** Only visitors with **Manage Loyalty** [permissions](https://support.wix.com/en/article/roles-permissions-accessing-roles-permissions) can update a loyalty program. You can override the permissions with the `wix-auth` [`elevate()`](wix-auth/elevate) function.
     *
     * This function is not a universal function and runs only on the backend.
     * @param loyaltyProgram - Loyalty program fields to update.
     * @public
     * @documentationMaturity preview
     * @requiredField loyaltyProgram
     * @adminMethod
     */
    function updateLoyaltyProgram(loyaltyProgram: LoyaltyProgram): Promise<UpdateLoyaltyProgramResponse>;
    /**
     * Activates a loyalty program.
     *
     * The `activateLoyaltyProgram()` function returns a Promise that resolves when the status of the loyalty program is successfully changed to `"ACTIVE"`.
     *
     * Before you begin, a Wix Loyalty Program must first be installed through your [dashboard](https://www.wix.com/my-account/site-selector/?buttonText=Select%20Site&title=Select%20a%20Site&autoSelectOnSingleSite=true&actionUrl=https:%2F%2Fwww.wix.com%2Fdashboard%2F%7B%7BmetaSiteId%7D%7D%2Floyalty-accounts/wizard/) or through the [Wix App Market](https://www.wix.com/app-market/loyalty). Initially when a loyalty program is installed, the status is set to `"DRAFT"`. You can change the program's status to `"ACTIVE"` with this function or through your [dashboard](https://www.wix.com/my-account/site-selector/?buttonText=Select%20Site&title=Select%20a%20Site&autoSelectOnSingleSite=true&actionUrl=https:%2F%2Fwww.wix.com%2Fdashboard%2F%7B%7BmetaSiteId%7D%7D%2Floyalty-accounts/wizard/). A site's customers can only earn or redeem points while the program status is `"ACTIVE"`.
     *
     * This function updates only the status of a loyalty program, to make other updates to the program, use the [`updateLoyaltyProgram()`](wix-loyalty-v2/programs/updateloyaltyprogram) function.
     *
     * To temporarily pause your loyalty program you must follow three steps:
     * 1. Remove all [`earnPoints()`](wix-loyalty-v2/accounts/earnpoints) functions and switch off all the "Earn Points" and "Rewards" toggles in the [Loyalty Program dashboard](https://www.wix.com/my-account/site-selector/?buttonText=Open%20Loyalty%20Program&title=Select%20a%20Site&autoSelectOnSingleSite=true&actionUrl=https://www.wix.com/dashboard/{{metaSiteId}}/loyalty-accounts/).
     * 1. Hide the loyalty page from your site.
     * 1. Delete the My Rewards page from the Member pages.
     * See [Pausing Your Loyalty Program](https://support.wix.com/en/article/wix-loyalty-program-pausing-your-loyalty-program) for more information.
     *
     * >**Note:** Only visitors with **Manage Loyalty** [permissions](https://support.wix.com/en/article/roles-permissions-accessing-roles-permissions) can activate a loyalty program. You can override the permissions with the `wix-auth` [`elevate()`](wix-auth/elevate) function.
     *
     * This function is not a universal function and runs only on the backend.
     * @public
     * @documentationMaturity preview
     * @adminMethod
     */
    function activateLoyaltyProgram(): Promise<ActivateLoyaltyProgramResponse>;
    interface GetLoyaltyProgramDescriptionOptions {
        /** List of description fields to retrieve. Supported values: `description`, `updatedDate`. */
        fields?: string[];
    }
    interface UpdateLoyaltyProgramDescriptionOptions {
        /** Loyalty program description to update. */
        description?: string;
    }
    type loyaltyV1Program_universal_d_LoyaltyProgram = LoyaltyProgram;
    type loyaltyV1Program_universal_d_PointDefinition = PointDefinition;
    type loyaltyV1Program_universal_d_ProgramStatus = ProgramStatus;
    const loyaltyV1Program_universal_d_ProgramStatus: typeof ProgramStatus;
    type loyaltyV1Program_universal_d_GetLoyaltyProgramRequest = GetLoyaltyProgramRequest;
    type loyaltyV1Program_universal_d_GetLoyaltyProgramResponse = GetLoyaltyProgramResponse;
    type loyaltyV1Program_universal_d_BulkGetLoyaltyProgramRequest = BulkGetLoyaltyProgramRequest;
    type loyaltyV1Program_universal_d_BulkGetLoyaltyProgramResponse = BulkGetLoyaltyProgramResponse;
    type loyaltyV1Program_universal_d_ProgramInSite = ProgramInSite;
    type loyaltyV1Program_universal_d_UpdateLoyaltyProgramRequest = UpdateLoyaltyProgramRequest;
    type loyaltyV1Program_universal_d_UpdateLoyaltyProgramResponse = UpdateLoyaltyProgramResponse;
    type loyaltyV1Program_universal_d_ActivateLoyaltyProgramRequest = ActivateLoyaltyProgramRequest;
    type loyaltyV1Program_universal_d_ActivateLoyaltyProgramResponse = ActivateLoyaltyProgramResponse;
    type loyaltyV1Program_universal_d_PauseLoyaltyProgramRequest = PauseLoyaltyProgramRequest;
    type loyaltyV1Program_universal_d_PauseLoyaltyProgramResponse = PauseLoyaltyProgramResponse;
    type loyaltyV1Program_universal_d_GetLoyaltyProgramDescriptionRequest = GetLoyaltyProgramDescriptionRequest;
    type loyaltyV1Program_universal_d_GetLoyaltyProgramDescriptionResponse = GetLoyaltyProgramDescriptionResponse;
    type loyaltyV1Program_universal_d_UpdateLoyaltyProgramDescriptionRequest = UpdateLoyaltyProgramDescriptionRequest;
    type loyaltyV1Program_universal_d_UpdateLoyaltyProgramDescriptionResponse = UpdateLoyaltyProgramDescriptionResponse;
    type loyaltyV1Program_universal_d_LoyaltyProgramDescriptionUpdated = LoyaltyProgramDescriptionUpdated;
    type loyaltyV1Program_universal_d_GetLoyaltyProgramPremiumFeaturesRequest = GetLoyaltyProgramPremiumFeaturesRequest;
    type loyaltyV1Program_universal_d_GetLoyaltyProgramPremiumFeaturesResponse = GetLoyaltyProgramPremiumFeaturesResponse;
    type loyaltyV1Program_universal_d_MetaSiteSpecialEvent = MetaSiteSpecialEvent;
    type loyaltyV1Program_universal_d_MetaSiteSpecialEventPayloadOneOf = MetaSiteSpecialEventPayloadOneOf;
    type loyaltyV1Program_universal_d_Asset = Asset;
    type loyaltyV1Program_universal_d_State = State;
    const loyaltyV1Program_universal_d_State: typeof State;
    type loyaltyV1Program_universal_d_SiteCreated = SiteCreated;
    type loyaltyV1Program_universal_d_SiteCreatedContext = SiteCreatedContext;
    const loyaltyV1Program_universal_d_SiteCreatedContext: typeof SiteCreatedContext;
    type loyaltyV1Program_universal_d_Namespace = Namespace;
    const loyaltyV1Program_universal_d_Namespace: typeof Namespace;
    type loyaltyV1Program_universal_d_SiteTransferred = SiteTransferred;
    type loyaltyV1Program_universal_d_SiteDeleted = SiteDeleted;
    type loyaltyV1Program_universal_d_DeleteContext = DeleteContext;
    type loyaltyV1Program_universal_d_DeleteStatus = DeleteStatus;
    const loyaltyV1Program_universal_d_DeleteStatus: typeof DeleteStatus;
    type loyaltyV1Program_universal_d_SiteUndeleted = SiteUndeleted;
    type loyaltyV1Program_universal_d_SitePublished = SitePublished;
    type loyaltyV1Program_universal_d_SiteUnpublished = SiteUnpublished;
    type loyaltyV1Program_universal_d_SiteMarkedAsTemplate = SiteMarkedAsTemplate;
    type loyaltyV1Program_universal_d_SiteMarkedAsWixSite = SiteMarkedAsWixSite;
    type loyaltyV1Program_universal_d_ServiceProvisioned = ServiceProvisioned;
    type loyaltyV1Program_universal_d_ServiceRemoved = ServiceRemoved;
    type loyaltyV1Program_universal_d_SiteRenamed = SiteRenamed;
    type loyaltyV1Program_universal_d_SiteHardDeleted = SiteHardDeleted;
    type loyaltyV1Program_universal_d_NamespaceChanged = NamespaceChanged;
    type loyaltyV1Program_universal_d_StudioAssigned = StudioAssigned;
    type loyaltyV1Program_universal_d_StudioUnassigned = StudioUnassigned;
    const loyaltyV1Program_universal_d_getLoyaltyProgram: typeof getLoyaltyProgram;
    type loyaltyV1Program_universal_d_BulkGetLoyaltyProgramOptions = BulkGetLoyaltyProgramOptions;
    const loyaltyV1Program_universal_d_updateLoyaltyProgram: typeof updateLoyaltyProgram;
    const loyaltyV1Program_universal_d_activateLoyaltyProgram: typeof activateLoyaltyProgram;
    type loyaltyV1Program_universal_d_GetLoyaltyProgramDescriptionOptions = GetLoyaltyProgramDescriptionOptions;
    type loyaltyV1Program_universal_d_UpdateLoyaltyProgramDescriptionOptions = UpdateLoyaltyProgramDescriptionOptions;
    namespace loyaltyV1Program_universal_d {
        export { __debug$2 as __debug, loyaltyV1Program_universal_d_LoyaltyProgram as LoyaltyProgram, loyaltyV1Program_universal_d_PointDefinition as PointDefinition, loyaltyV1Program_universal_d_ProgramStatus as ProgramStatus, loyaltyV1Program_universal_d_GetLoyaltyProgramRequest as GetLoyaltyProgramRequest, loyaltyV1Program_universal_d_GetLoyaltyProgramResponse as GetLoyaltyProgramResponse, loyaltyV1Program_universal_d_BulkGetLoyaltyProgramRequest as BulkGetLoyaltyProgramRequest, loyaltyV1Program_universal_d_BulkGetLoyaltyProgramResponse as BulkGetLoyaltyProgramResponse, loyaltyV1Program_universal_d_ProgramInSite as ProgramInSite, loyaltyV1Program_universal_d_UpdateLoyaltyProgramRequest as UpdateLoyaltyProgramRequest, loyaltyV1Program_universal_d_UpdateLoyaltyProgramResponse as UpdateLoyaltyProgramResponse, loyaltyV1Program_universal_d_ActivateLoyaltyProgramRequest as ActivateLoyaltyProgramRequest, loyaltyV1Program_universal_d_ActivateLoyaltyProgramResponse as ActivateLoyaltyProgramResponse, loyaltyV1Program_universal_d_PauseLoyaltyProgramRequest as PauseLoyaltyProgramRequest, loyaltyV1Program_universal_d_PauseLoyaltyProgramResponse as PauseLoyaltyProgramResponse, loyaltyV1Program_universal_d_GetLoyaltyProgramDescriptionRequest as GetLoyaltyProgramDescriptionRequest, loyaltyV1Program_universal_d_GetLoyaltyProgramDescriptionResponse as GetLoyaltyProgramDescriptionResponse, loyaltyV1Program_universal_d_UpdateLoyaltyProgramDescriptionRequest as UpdateLoyaltyProgramDescriptionRequest, loyaltyV1Program_universal_d_UpdateLoyaltyProgramDescriptionResponse as UpdateLoyaltyProgramDescriptionResponse, loyaltyV1Program_universal_d_LoyaltyProgramDescriptionUpdated as LoyaltyProgramDescriptionUpdated, loyaltyV1Program_universal_d_GetLoyaltyProgramPremiumFeaturesRequest as GetLoyaltyProgramPremiumFeaturesRequest, loyaltyV1Program_universal_d_GetLoyaltyProgramPremiumFeaturesResponse as GetLoyaltyProgramPremiumFeaturesResponse, loyaltyV1Program_universal_d_MetaSiteSpecialEvent as MetaSiteSpecialEvent, loyaltyV1Program_universal_d_MetaSiteSpecialEventPayloadOneOf as MetaSiteSpecialEventPayloadOneOf, loyaltyV1Program_universal_d_Asset as Asset, loyaltyV1Program_universal_d_State as State, loyaltyV1Program_universal_d_SiteCreated as SiteCreated, loyaltyV1Program_universal_d_SiteCreatedContext as SiteCreatedContext, loyaltyV1Program_universal_d_Namespace as Namespace, loyaltyV1Program_universal_d_SiteTransferred as SiteTransferred, loyaltyV1Program_universal_d_SiteDeleted as SiteDeleted, loyaltyV1Program_universal_d_DeleteContext as DeleteContext, loyaltyV1Program_universal_d_DeleteStatus as DeleteStatus, loyaltyV1Program_universal_d_SiteUndeleted as SiteUndeleted, loyaltyV1Program_universal_d_SitePublished as SitePublished, loyaltyV1Program_universal_d_SiteUnpublished as SiteUnpublished, loyaltyV1Program_universal_d_SiteMarkedAsTemplate as SiteMarkedAsTemplate, loyaltyV1Program_universal_d_SiteMarkedAsWixSite as SiteMarkedAsWixSite, loyaltyV1Program_universal_d_ServiceProvisioned as ServiceProvisioned, loyaltyV1Program_universal_d_ServiceRemoved as ServiceRemoved, loyaltyV1Program_universal_d_SiteRenamed as SiteRenamed, loyaltyV1Program_universal_d_SiteHardDeleted as SiteHardDeleted, loyaltyV1Program_universal_d_NamespaceChanged as NamespaceChanged, loyaltyV1Program_universal_d_StudioAssigned as StudioAssigned, loyaltyV1Program_universal_d_StudioUnassigned as StudioUnassigned, Empty$1 as Empty, DomainEvent$1 as DomainEvent, DomainEventBodyOneOf$1 as DomainEventBodyOneOf, EntityCreatedEvent$1 as EntityCreatedEvent, EntityUpdatedEvent$1 as EntityUpdatedEvent, EntityDeletedEvent$1 as EntityDeletedEvent, ActionEvent$1 as ActionEvent, loyaltyV1Program_universal_d_getLoyaltyProgram as getLoyaltyProgram, loyaltyV1Program_universal_d_BulkGetLoyaltyProgramOptions as BulkGetLoyaltyProgramOptions, loyaltyV1Program_universal_d_updateLoyaltyProgram as updateLoyaltyProgram, loyaltyV1Program_universal_d_activateLoyaltyProgram as activateLoyaltyProgram, loyaltyV1Program_universal_d_GetLoyaltyProgramDescriptionOptions as GetLoyaltyProgramDescriptionOptions, loyaltyV1Program_universal_d_UpdateLoyaltyProgramDescriptionOptions as UpdateLoyaltyProgramDescriptionOptions, };
    }
    const __debug$1: {
        verboseLogging: {
            on: () => boolean;
            off: () => boolean;
        };
    };
    /**
     * A loyalty reward is an object a customer can redeem with loyalty points.
     * Redeeming a reward then creates a loyalty coupon that the customer can use.
     */
    interface Reward extends RewardTypeDetailsOneOf {
        /** Discount details. */
        discountAmount?: DiscountAmount;
        /** Coupon details. */
        couponReward?: CouponReward;
        /**
         * Reward ID.
         * @readonly
         */
        _id?: string | null;
        /** Reward name. */
        name?: string;
        /**
         * Whether the reward is active.
         *
         * Default: `"false"`
         */
        active?: boolean;
        /**
         * Reward type.
         *
         * + `"DISCOUNT_AMOUNT"`: Discount reward. Only available for Wix Restaurants. [Learn more about discounts.](https://support.wix.com/en/article/wix-restaurants-creating-discounts-for-your-customers)
         * + `"COUPON_REWARD"`: Coupon reward. [Learn more about coupons.](https://support.wix.com/en/article/using-coupons-as-loyalty-rewards)
         * + `"COUPON"`: **Deprecated.** Use `"COUPON_REWARD"` instead.
         */
        type?: RewardType;
        /**
         * Revision number, which increments by `"1"` each time the loyalty reward is updated.
         *
         * To prevent conflicting changes, the current `revision` must be passed when updating the loyalty reward.
         * @readonly
         */
        revision?: string | null;
        /**
         * Date and time the reward was created.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * Date and time the reward was last updated.
         * @readonly
         */
        _updatedDate?: Date;
    }
    /** @oneof */
    interface RewardTypeDetailsOneOf {
        /** Discount details. */
        discountAmount?: DiscountAmount;
        /** Coupon details. */
        couponReward?: CouponReward;
    }
    /** Available reward types. */
    enum RewardType {
        UNDEFINED = "UNDEFINED",
        DISCOUNT_AMOUNT = "DISCOUNT_AMOUNT",
        COUPON = "COUPON",
        COUPON_REWARD = "COUPON_REWARD"
    }
    /** TODO add [(wix.api.minSize) = 1, (wix.api.maxSize) = 20] to DiscountAmount; */
    interface DiscountAmount {
        /** Discount details for each tier. */
        configsByTier?: DiscountAmountConfig[];
    }
    /** TODO after migration for cost_in_points use [(wix.api.min) = 1, (wix.api.max) = 9999999]; */
    interface DiscountAmountConfig {
        /** Discount amount. Must be a positive value. */
        amount?: string;
        /** Tier ID, or empty if config applies to the base tier. */
        tierId?: string | null;
        /** Amount of points required to redeem the reward. */
        costInPoints?: number;
    }
    interface CouponReward extends CouponRewardDiscountTypeOneOf, CouponRewardScopeOrMinSubtotalOneOf {
        /** Discount as a fixed amount. */
        fixedAmount?: FixedAmountDiscount;
        /** Discount as a percentage. */
        percentage?: PercentageDiscount;
        /** Free shipping. */
        freeShipping?: FreeShippingDiscount;
        /** Limit the coupon to carts with a subtotal greater than this number. */
        minimumSubtotal?: number;
        /**
         * Specifies the type of line items this coupon will apply to.
         *
         * For more information, see the Coupons API.
         */
        scope?: CouponScope;
        /** Whether the coupon is limited to one item. */
        limitedToOneItem?: boolean | null;
        /**
         * Whether the coupon applies to subscription products.
         *
         * If set to `true`, the discount will apply to all billing cycles.
         */
        appliesToSubscriptions?: boolean | null;
        /** Reserved for internal use. */
        discountedCycleCount?: number | null;
    }
    /** @oneof */
    interface CouponRewardDiscountTypeOneOf {
        /** Discount as a fixed amount. */
        fixedAmount?: FixedAmountDiscount;
        /** Discount as a percentage. */
        percentage?: PercentageDiscount;
        /** Free shipping. */
        freeShipping?: FreeShippingDiscount;
    }
    /** @oneof */
    interface CouponRewardScopeOrMinSubtotalOneOf {
        /** Limit the coupon to carts with a subtotal greater than this number. */
        minimumSubtotal?: number;
        /**
         * Specifies the type of line items this coupon will apply to.
         *
         * For more information, see the Coupons API.
         */
        scope?: CouponScope;
    }
    /** TODO add [(wix.api.minSize) = 1, (wix.api.maxSize) = 20] */
    interface FixedAmountDiscount {
        /** Discount details for each tier. */
        configsByTier?: FixedAmountDiscountConfig[];
    }
    interface FixedAmountDiscountConfig {
        /** Tier ID, or empty if config applies to the base tier. */
        tierId?: string | null;
        /** Amount of points required to redeem the reward. */
        costInPoints?: number;
        /** Discount amount. */
        amount?: number;
    }
    /** TODO add [(wix.api.minSize) = 1, (wix.api.maxSize) = 20] */
    interface PercentageDiscount {
        /** Discount details for each tier. */
        configsByTier?: PercentageDiscountConfig[];
    }
    interface PercentageDiscountConfig {
        /** Tier ID, or empty if config applies to the base tier. */
        tierId?: string | null;
        /** Amount of points required to redeem the reward. */
        costInPoints?: number;
        /** Percentage discount. */
        percentage?: number;
    }
    /** TODO add [(wix.api.minSize) = 1, (wix.api.maxSize) = 20] */
    interface FreeShippingDiscount {
        /** Discount details for each tier. */
        configsByTier?: FreeShippingDiscountConfig[];
    }
    interface FreeShippingDiscountConfig {
        /** Tier ID, or empty if config applies to the base tier. */
        tierId?: string | null;
        /** Amount of points required to redeem the reward. */
        costInPoints?: number;
    }
    interface CouponScope {
        /**
         * Scope namespace.
         *
         * See the Coupons API for valid namespaces.
         */
        namespace?: string;
        /**
         * Coupon scope's applied group.
         *
         * See the Coupons API for valid groups.
         */
        group?: Group;
    }
    interface Group {
        /**
         * Name of coupon scope's group.
         *
         * See the Coupons API for valid groups.
         */
        name?: string;
        /** Entity ID, if the coupon scope is limited to just one item. */
        entityId?: string | null;
    }
    interface Coupon {
        templateId?: string;
        /** @readonly */
        deleted?: boolean | null;
        configs?: CouponConfig[];
    }
    interface CouponConfig {
        /** Amount of points required to receive the reward. */
        requiredPoints?: number;
        /**
         * Tier ID, or empty if config applies to the base tier.
         * @readonly
         */
        tierId?: string | null;
    }
    interface RewardDisabled {
    }
    interface CreateRewardRequest {
        /** Reward to create. */
        reward: Reward;
    }
    interface CreateRewardResponse {
        /** Created reward. */
        reward?: Reward;
    }
    interface BulkCreateRewardsRequest {
        /** Rewards to create. */
        rewards: Reward[];
    }
    interface BulkCreateRewardsResponse {
        /** Created rewards. */
        results?: BulkRewardResult[];
        /** Total successes and failures of the bulk create rewards action. */
        bulkActionMetadata?: BulkActionMetadata$1;
    }
    interface BulkRewardResult {
        itemMetadata?: ItemMetadata$1;
        item?: Reward;
    }
    interface ItemMetadata$1 {
        /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
        _id?: string | null;
        /** Index of the item within the request array. Allows for correlation between request and response items. */
        originalIndex?: number;
        /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
        success?: boolean;
        /** Details about the error in case of failure. */
        error?: ApplicationError$1;
    }
    interface ApplicationError$1 {
        /** Error code. */
        code?: string;
        /** Description of the error. */
        description?: string;
        /** Data related to the error. */
        data?: Record<string, any> | null;
    }
    interface BulkActionMetadata$1 {
        /** Number of items that were successfully processed. */
        totalSuccesses?: number;
        /** Number of items that couldn't be processed. */
        totalFailures?: number;
        /** Number of failures without details because detailed failure threshold was exceeded. */
        undetailedFailures?: number;
    }
    interface GetRewardRequest {
        /** ID of the reward to retrieve. */
        _id: string;
    }
    interface GetRewardResponse {
        /** Retrieved reward. */
        reward?: Reward;
    }
    interface BulkGetRewardsRequest {
        metaSiteIds?: string[];
    }
    interface BulkGetRewardsResponse {
        rewardsInSite?: RewardsInSite[];
    }
    interface RewardsInSite {
        metaSiteId?: string;
        rewards?: Reward[];
    }
    interface UpdateRewardRequest {
        /** Reward information to update. */
        reward: Reward;
    }
    interface UpdateRewardResponse {
        /** Updated reward. */
        reward?: Reward;
    }
    interface DeleteRewardRequest {
        /** ID of the reward to delete. */
        _id: string;
        /**
         * Revision number, which increments by `"1"` each time the reward is updated.
         *
         * To prevent conflicting changes, the current `revision` must be passed when deleting the reward.
         */
        revision?: string;
    }
    interface DeleteRewardResponse {
    }
    interface ListRewardsRequest {
        /** Pagination options. */
        cursorPaging?: CursorPaging;
    }
    interface CursorPaging {
        /** Number of items to load. */
        limit?: number | null;
        /**
         * Pointer to the next or previous page in the list of results.
         *
         * You can get the relevant cursor token
         * from the `pagingMetadata` object in the previous call's response.
         * Not relevant for the first request.
         */
        cursor?: string | null;
    }
    interface ListRewardsResponse {
        /** Retrieved loyalty rewards. */
        rewards?: Reward[];
        /** Details on the paged set of results returned. */
        pagingMetadata?: PagingMetadataV2;
    }
    interface PagingMetadataV2 {
        /** Number of items returned in the response. */
        count?: number | null;
        /** Offset that was requested. */
        offset?: number | null;
        /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
        total?: number | null;
        /** Flag that indicates the server failed to calculate the `total` field. */
        tooManyToCount?: boolean | null;
        /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
        cursors?: Cursors;
    }
    interface Cursors {
        /** Cursor pointing to next page in the list of results. */
        next?: string | null;
        /** Cursor pointing to previous page in the list of results. */
        prev?: string | null;
    }
    interface DomainEvent extends DomainEventBodyOneOf {
        createdEvent?: EntityCreatedEvent;
        updatedEvent?: EntityUpdatedEvent;
        deletedEvent?: EntityDeletedEvent;
        actionEvent?: ActionEvent;
        /** random GUID so clients can tell if event was already handled */
        _id?: string;
        /**
         * Assumes actions are also always typed to an entity_type
         * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
         */
        entityFqdn?: string;
        /**
         * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
         * This is although the created/updated/deleted notion is duplication of the oneof types
         * Example: created/updated/deleted/started/completed/email_opened
         */
        slug?: string;
        /**
         * Assuming that all messages including Actions have id
         * Example: The id of the specific order, the id of a specific campaign
         */
        entityId?: string;
        /** The time of the event. Useful if there was a delay in dispatching */
        eventTime?: Date;
        /**
         * A field that should be set if this event was triggered by an anonymize request.
         * For example you must set it to true when sending an event as a result of a GDPR right to be forgotten request.
         * NOTE: This field is not relevant for `EntityCreatedEvent` but is located here for better ergonomics of consumers.
         */
        triggeredByAnonymizeRequest?: boolean | null;
        /** If present, indicates the action that triggered the event. */
        originatedFrom?: string | null;
        /**
         * A sequence number defining the order of updates to the underlying entity.
         * For example, given that some entity was updated at 16:00 and than again at 16:01,
         * it is guaranteed that the sequence number of the second update is strictly higher than the first.
         * As the consumer, you can use this value to ensure that you handle messages in the correct order.
         * To do so, you will need to persist this number on your end, and compare the sequence number from the
         * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
         */
        entityEventSequence?: string | null;
    }
    /** @oneof */
    interface DomainEventBodyOneOf {
        createdEvent?: EntityCreatedEvent;
        updatedEvent?: EntityUpdatedEvent;
        deletedEvent?: EntityDeletedEvent;
        actionEvent?: ActionEvent;
    }
    interface EntityCreatedEvent {
        entityAsJson?: string;
    }
    interface EntityUpdatedEvent {
        /**
         * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
         * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
         * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
         */
        currentEntityAsJson?: string;
    }
    interface EntityDeletedEvent {
    }
    interface ActionEvent {
        bodyAsJson?: string;
    }
    interface Empty {
    }
    interface QueryRewardsRequest {
        query: CursorQuery;
    }
    interface CursorQuery extends CursorQueryPagingMethodOneOf {
        /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
        cursorPaging?: CursorPaging;
        /**
         * Filter object in the following format:
         * `"filter" : {
         * "fieldName1": "value1",
         * "fieldName2":{"$operator":"value2"}
         * }`
         * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
         */
        filter?: Record<string, any> | null;
        /**
         * Sort object in the following format:
         * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
         */
        sort?: Sorting[];
    }
    /** @oneof */
    interface CursorQueryPagingMethodOneOf {
        /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
        cursorPaging?: CursorPaging;
    }
    interface Sorting {
        /** Name of the field to sort by. */
        fieldName?: string;
        /** Sort order. */
        order?: SortOrder;
    }
    enum SortOrder {
        ASC = "ASC",
        DESC = "DESC"
    }
    interface QueryRewardsResponse {
        /** Retrieved loyalty rewards. */
        rewards?: Reward[];
        /** Details on the paged set of results returned. */
        pagingMetadata?: CursorPagingMetadata;
    }
    interface CursorPagingMetadata {
        /** Number of items returned in the response. */
        count?: number | null;
        /** Offset that was requested. */
        cursors?: Cursors;
        /**
         * Indicates if there are more results after the current page.
         * If `true`, another page of results can be retrieved.
         * If `false`, this is the last page.
         */
        hasNext?: boolean | null;
    }
    /**
     * Creates a reward that can be redeemed with loyalty points.
     *
     * When a customer redeems a reward, a loyalty coupon is created
     * based on the specifications detailed in either the `discountAmount` or `couponReward` fields. This coupon can
     * then be used by the customer to receive the discount. Note that while the Rewards API uses coupon scopes and specifications,
     * no coupon is actually created until a reward is redeemed with points.
     * See the Coupons API for more information about coupons.
     *
     * A reward's `active` status defaults to `false`. To make the reward available to customers,
     * either set the `active` field to `true` during creation or call [`updateReward()`](#updatereward)
     * to change the status.
     *
     * To customize a reward for each loyalty tier, use the `configsByTier` parameter.
     * This allows you to specify the amount of the earned discount, the cost in loyalty points
     * to redeem the reward, and the tier to which this configuration applies. Each tier requires its own
     * `configsByTier` configuration. To create a reward that is available to loyalty accounts in the base tier,
     * leave the `tierId` field empty. See the Loyalty Tiers API for more information on tiers.
     *
     * This function is not a universal function and runs only on the backend.
     * @param reward - Reward to create.
     * @public
     * @documentationMaturity preview
     * @requiredField reward
     * @requiredField reward.name
     * @adminMethod
     */
    function createReward(reward: Reward): Promise<CreateRewardResponse>;
    /**
     * Retrieves a reward.
     * @param _id - ID of the reward to retrieve.
     * @public
     * @documentationMaturity preview
     * @requiredField _id
     */
    function getReward(_id: string): Promise<GetRewardResponse>;
    interface BulkGetRewardsOptions {
        metaSiteIds?: string[];
    }
    /**
     * Updates a loyalty reward.
     *
     * Use this endpoint to update details of a reward, such as the name, whether or not a reward is active,
     * or the amount of points it costs to redeem. Also use this endpoint to add new tiers that are eligible to redeem a reward.
     *
     * You may not change the `type` of a reward. That is set upon creation and cannot be updated.
     *
     * This function is not a universal function and runs only on the backend.
     * @param _id - Reward ID.
     * @public
     * @documentationMaturity preview
     * @requiredField _id
     * @requiredField reward
     * @requiredField reward.name
     * @requiredField reward.revision
     * @param reward - Reward info to update.
     * @adminMethod
     */
    function updateReward(_id: string | null, reward: UpdateReward): Promise<UpdateRewardResponse>;
    interface UpdateReward {
        /** Discount details. */
        discountAmount?: DiscountAmount;
        /** Coupon details. */
        couponReward?: CouponReward;
        /**
         * Reward ID.
         * @readonly
         */
        _id?: string | null;
        /** Reward name. */
        name?: string;
        /**
         * Whether the reward is active.
         *
         * Default: `"false"`
         */
        active?: boolean;
        /**
         * Reward type.
         *
         * + `"DISCOUNT_AMOUNT"`: Discount reward. Only available for Wix Restaurants. [Learn more about discounts.](https://support.wix.com/en/article/wix-restaurants-creating-discounts-for-your-customers)
         * + `"COUPON_REWARD"`: Coupon reward. [Learn more about coupons.](https://support.wix.com/en/article/using-coupons-as-loyalty-rewards)
         * + `"COUPON"`: **Deprecated.** Use `"COUPON_REWARD"` instead.
         */
        type?: RewardType;
        /**
         * Revision number, which increments by `"1"` each time the loyalty reward is updated.
         *
         * To prevent conflicting changes, the current `revision` must be passed when updating the loyalty reward.
         * @readonly
         */
        revision?: string | null;
        /**
         * Date and time the reward was created.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * Date and time the reward was last updated.
         * @readonly
         */
        _updatedDate?: Date;
    }
    /**
     * Deletes a reward.
     *
     * This function is not a universal function and runs only on the backend.
     * @param _id - ID of the reward to delete.
     * @param revision - Revision number, which increments by `"1"` each time the reward is updated.
     *
     * To prevent conflicting changes, the current `revision` must be passed when deleting the reward.
     * @public
     * @documentationMaturity preview
     * @requiredField _id
     * @requiredField revision
     * @adminMethod
     */
    function deleteReward(_id: string, revision: string): Promise<void>;
    /**
     * Retrieves a list of rewards.
     *
     * Only rewards with `"active"` set to `"true"` will be retrieved. The list includes rewards that are currently
     * unredeemable due to insufficient points held by any customers.
     * @public
     * @documentationMaturity preview
     * @param options - List options.
     */
    function listRewards(options?: ListRewardsOptions): Promise<ListRewardsResponse>;
    interface ListRewardsOptions {
        /** Pagination options. */
        cursorPaging?: CursorPaging;
    }
    type loyaltyV1Reward_universal_d_Reward = Reward;
    type loyaltyV1Reward_universal_d_RewardTypeDetailsOneOf = RewardTypeDetailsOneOf;
    type loyaltyV1Reward_universal_d_RewardType = RewardType;
    const loyaltyV1Reward_universal_d_RewardType: typeof RewardType;
    type loyaltyV1Reward_universal_d_DiscountAmount = DiscountAmount;
    type loyaltyV1Reward_universal_d_DiscountAmountConfig = DiscountAmountConfig;
    type loyaltyV1Reward_universal_d_CouponReward = CouponReward;
    type loyaltyV1Reward_universal_d_CouponRewardDiscountTypeOneOf = CouponRewardDiscountTypeOneOf;
    type loyaltyV1Reward_universal_d_CouponRewardScopeOrMinSubtotalOneOf = CouponRewardScopeOrMinSubtotalOneOf;
    type loyaltyV1Reward_universal_d_FixedAmountDiscount = FixedAmountDiscount;
    type loyaltyV1Reward_universal_d_FixedAmountDiscountConfig = FixedAmountDiscountConfig;
    type loyaltyV1Reward_universal_d_PercentageDiscount = PercentageDiscount;
    type loyaltyV1Reward_universal_d_PercentageDiscountConfig = PercentageDiscountConfig;
    type loyaltyV1Reward_universal_d_FreeShippingDiscount = FreeShippingDiscount;
    type loyaltyV1Reward_universal_d_FreeShippingDiscountConfig = FreeShippingDiscountConfig;
    type loyaltyV1Reward_universal_d_CouponScope = CouponScope;
    type loyaltyV1Reward_universal_d_Group = Group;
    type loyaltyV1Reward_universal_d_Coupon = Coupon;
    type loyaltyV1Reward_universal_d_CouponConfig = CouponConfig;
    type loyaltyV1Reward_universal_d_RewardDisabled = RewardDisabled;
    type loyaltyV1Reward_universal_d_CreateRewardRequest = CreateRewardRequest;
    type loyaltyV1Reward_universal_d_CreateRewardResponse = CreateRewardResponse;
    type loyaltyV1Reward_universal_d_BulkCreateRewardsRequest = BulkCreateRewardsRequest;
    type loyaltyV1Reward_universal_d_BulkCreateRewardsResponse = BulkCreateRewardsResponse;
    type loyaltyV1Reward_universal_d_BulkRewardResult = BulkRewardResult;
    type loyaltyV1Reward_universal_d_GetRewardRequest = GetRewardRequest;
    type loyaltyV1Reward_universal_d_GetRewardResponse = GetRewardResponse;
    type loyaltyV1Reward_universal_d_BulkGetRewardsRequest = BulkGetRewardsRequest;
    type loyaltyV1Reward_universal_d_BulkGetRewardsResponse = BulkGetRewardsResponse;
    type loyaltyV1Reward_universal_d_RewardsInSite = RewardsInSite;
    type loyaltyV1Reward_universal_d_UpdateRewardRequest = UpdateRewardRequest;
    type loyaltyV1Reward_universal_d_UpdateRewardResponse = UpdateRewardResponse;
    type loyaltyV1Reward_universal_d_DeleteRewardRequest = DeleteRewardRequest;
    type loyaltyV1Reward_universal_d_DeleteRewardResponse = DeleteRewardResponse;
    type loyaltyV1Reward_universal_d_ListRewardsRequest = ListRewardsRequest;
    type loyaltyV1Reward_universal_d_CursorPaging = CursorPaging;
    type loyaltyV1Reward_universal_d_ListRewardsResponse = ListRewardsResponse;
    type loyaltyV1Reward_universal_d_PagingMetadataV2 = PagingMetadataV2;
    type loyaltyV1Reward_universal_d_Cursors = Cursors;
    type loyaltyV1Reward_universal_d_DomainEvent = DomainEvent;
    type loyaltyV1Reward_universal_d_DomainEventBodyOneOf = DomainEventBodyOneOf;
    type loyaltyV1Reward_universal_d_EntityCreatedEvent = EntityCreatedEvent;
    type loyaltyV1Reward_universal_d_EntityUpdatedEvent = EntityUpdatedEvent;
    type loyaltyV1Reward_universal_d_EntityDeletedEvent = EntityDeletedEvent;
    type loyaltyV1Reward_universal_d_ActionEvent = ActionEvent;
    type loyaltyV1Reward_universal_d_Empty = Empty;
    type loyaltyV1Reward_universal_d_QueryRewardsRequest = QueryRewardsRequest;
    type loyaltyV1Reward_universal_d_CursorQuery = CursorQuery;
    type loyaltyV1Reward_universal_d_CursorQueryPagingMethodOneOf = CursorQueryPagingMethodOneOf;
    type loyaltyV1Reward_universal_d_Sorting = Sorting;
    type loyaltyV1Reward_universal_d_SortOrder = SortOrder;
    const loyaltyV1Reward_universal_d_SortOrder: typeof SortOrder;
    type loyaltyV1Reward_universal_d_QueryRewardsResponse = QueryRewardsResponse;
    type loyaltyV1Reward_universal_d_CursorPagingMetadata = CursorPagingMetadata;
    const loyaltyV1Reward_universal_d_createReward: typeof createReward;
    const loyaltyV1Reward_universal_d_getReward: typeof getReward;
    type loyaltyV1Reward_universal_d_BulkGetRewardsOptions = BulkGetRewardsOptions;
    const loyaltyV1Reward_universal_d_updateReward: typeof updateReward;
    type loyaltyV1Reward_universal_d_UpdateReward = UpdateReward;
    const loyaltyV1Reward_universal_d_deleteReward: typeof deleteReward;
    const loyaltyV1Reward_universal_d_listRewards: typeof listRewards;
    type loyaltyV1Reward_universal_d_ListRewardsOptions = ListRewardsOptions;
    namespace loyaltyV1Reward_universal_d {
        export { __debug$1 as __debug, loyaltyV1Reward_universal_d_Reward as Reward, loyaltyV1Reward_universal_d_RewardTypeDetailsOneOf as RewardTypeDetailsOneOf, loyaltyV1Reward_universal_d_RewardType as RewardType, loyaltyV1Reward_universal_d_DiscountAmount as DiscountAmount, loyaltyV1Reward_universal_d_DiscountAmountConfig as DiscountAmountConfig, loyaltyV1Reward_universal_d_CouponReward as CouponReward, loyaltyV1Reward_universal_d_CouponRewardDiscountTypeOneOf as CouponRewardDiscountTypeOneOf, loyaltyV1Reward_universal_d_CouponRewardScopeOrMinSubtotalOneOf as CouponRewardScopeOrMinSubtotalOneOf, loyaltyV1Reward_universal_d_FixedAmountDiscount as FixedAmountDiscount, loyaltyV1Reward_universal_d_FixedAmountDiscountConfig as FixedAmountDiscountConfig, loyaltyV1Reward_universal_d_PercentageDiscount as PercentageDiscount, loyaltyV1Reward_universal_d_PercentageDiscountConfig as PercentageDiscountConfig, loyaltyV1Reward_universal_d_FreeShippingDiscount as FreeShippingDiscount, loyaltyV1Reward_universal_d_FreeShippingDiscountConfig as FreeShippingDiscountConfig, loyaltyV1Reward_universal_d_CouponScope as CouponScope, loyaltyV1Reward_universal_d_Group as Group, loyaltyV1Reward_universal_d_Coupon as Coupon, loyaltyV1Reward_universal_d_CouponConfig as CouponConfig, loyaltyV1Reward_universal_d_RewardDisabled as RewardDisabled, loyaltyV1Reward_universal_d_CreateRewardRequest as CreateRewardRequest, loyaltyV1Reward_universal_d_CreateRewardResponse as CreateRewardResponse, loyaltyV1Reward_universal_d_BulkCreateRewardsRequest as BulkCreateRewardsRequest, loyaltyV1Reward_universal_d_BulkCreateRewardsResponse as BulkCreateRewardsResponse, loyaltyV1Reward_universal_d_BulkRewardResult as BulkRewardResult, ItemMetadata$1 as ItemMetadata, ApplicationError$1 as ApplicationError, BulkActionMetadata$1 as BulkActionMetadata, loyaltyV1Reward_universal_d_GetRewardRequest as GetRewardRequest, loyaltyV1Reward_universal_d_GetRewardResponse as GetRewardResponse, loyaltyV1Reward_universal_d_BulkGetRewardsRequest as BulkGetRewardsRequest, loyaltyV1Reward_universal_d_BulkGetRewardsResponse as BulkGetRewardsResponse, loyaltyV1Reward_universal_d_RewardsInSite as RewardsInSite, loyaltyV1Reward_universal_d_UpdateRewardRequest as UpdateRewardRequest, loyaltyV1Reward_universal_d_UpdateRewardResponse as UpdateRewardResponse, loyaltyV1Reward_universal_d_DeleteRewardRequest as DeleteRewardRequest, loyaltyV1Reward_universal_d_DeleteRewardResponse as DeleteRewardResponse, loyaltyV1Reward_universal_d_ListRewardsRequest as ListRewardsRequest, loyaltyV1Reward_universal_d_CursorPaging as CursorPaging, loyaltyV1Reward_universal_d_ListRewardsResponse as ListRewardsResponse, loyaltyV1Reward_universal_d_PagingMetadataV2 as PagingMetadataV2, loyaltyV1Reward_universal_d_Cursors as Cursors, loyaltyV1Reward_universal_d_DomainEvent as DomainEvent, loyaltyV1Reward_universal_d_DomainEventBodyOneOf as DomainEventBodyOneOf, loyaltyV1Reward_universal_d_EntityCreatedEvent as EntityCreatedEvent, loyaltyV1Reward_universal_d_EntityUpdatedEvent as EntityUpdatedEvent, loyaltyV1Reward_universal_d_EntityDeletedEvent as EntityDeletedEvent, loyaltyV1Reward_universal_d_ActionEvent as ActionEvent, loyaltyV1Reward_universal_d_Empty as Empty, loyaltyV1Reward_universal_d_QueryRewardsRequest as QueryRewardsRequest, loyaltyV1Reward_universal_d_CursorQuery as CursorQuery, loyaltyV1Reward_universal_d_CursorQueryPagingMethodOneOf as CursorQueryPagingMethodOneOf, loyaltyV1Reward_universal_d_Sorting as Sorting, loyaltyV1Reward_universal_d_SortOrder as SortOrder, loyaltyV1Reward_universal_d_QueryRewardsResponse as QueryRewardsResponse, loyaltyV1Reward_universal_d_CursorPagingMetadata as CursorPagingMetadata, loyaltyV1Reward_universal_d_createReward as createReward, loyaltyV1Reward_universal_d_getReward as getReward, loyaltyV1Reward_universal_d_BulkGetRewardsOptions as BulkGetRewardsOptions, loyaltyV1Reward_universal_d_updateReward as updateReward, loyaltyV1Reward_universal_d_UpdateReward as UpdateReward, loyaltyV1Reward_universal_d_deleteReward as deleteReward, loyaltyV1Reward_universal_d_listRewards as listRewards, loyaltyV1Reward_universal_d_ListRewardsOptions as ListRewardsOptions, };
    }
    const __debug: {
        verboseLogging: {
            on: () => boolean;
            off: () => boolean;
        };
    };
    /**
     * A tier is a loyalty level that customers are assigned to based on the amount of points they earn.
     * Read more about loyalty tiers [here](https://support.wix.com/en/article/about-tiers).
     */
    interface Tier {
        /**
         * Tier ID.
         * @readonly
         */
        _id?: string | null;
        /** Information about the tier. */
        tierDefinition?: TierDefinition;
        /**
         * The amount of points required to be in this tier.
         *
         * Min: `"0"`
         *
         * Max: `"9999999"`
         */
        requiredPoints?: number;
        /**
         * Revision number, which increments by `"1"` each time the loyalty tier is updated.
         *
         * To prevent conflicting changes, the current `revision` must be passed when updating the loyalty tier.
         * @readonly
         */
        revision?: string | null;
        /**
         * Date and time the tier was created.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * Date and time the tier was last updated.
         * @readonly
         */
        _updatedDate?: Date;
    }
    /** Information about the tier. */
    interface TierDefinition {
        /** Details about the tier icon. */
        icon?: string;
        /**
         * Tier name.
         *
         * Min: 2 characters
         *
         * Max: 50 characters
         */
        name?: string | null;
        /**
         * Tier desciption.
         *
         * Max: 70 characters
         */
        description?: string | null;
    }
    interface TiersProgramSettingsChanged {
        programSettings?: TiersProgramSettings;
    }
    /** There can be single TiersSettings per site and it's global (i.e. applies to all program's tiers) */
    interface TiersProgramSettings extends TiersProgramSettingsPeriodOneOf {
        /**
         * *Required.** Period of time used to calculate loyalty points for tier assignment.
         *
         * The loyalty points accumulated during this period determine if the account meets a tier's required point threshold.
         */
        rollingWindow?: RollingWindow;
        /** Tiers program status. */
        status?: Status;
        /**
         * Revision number, which increments by `"1"` each time the loyalty tiers settings are updated.
         *
         * To prevent conflicting changes, the current `revision` must be passed when updating the loyalty tiers settings.
         */
        revision?: string | null;
        /**
         * Date and time the loyalty tiers program was created.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * Date and time the loyalty tiers program was last updated.
         * @readonly
         */
        _updatedDate?: Date;
        /**
         * Information about the base loyalty tier.
         *
         * The base tier is the default tier for any account that is unassigned for not meeting
         * the required points threshold of any other tier.
         */
        baseTierDefinition?: TierDefinition;
    }
    /** @oneof */
    interface TiersProgramSettingsPeriodOneOf {
        /**
         * *Required.** Period of time used to calculate loyalty points for tier assignment.
         *
         * The loyalty points accumulated during this period determine if the account meets a tier's required point threshold.
         */
        rollingWindow?: RollingWindow;
    }
    enum Status {
        UNKNOWN = "UNKNOWN",
        /** Tiers are disabled */
        DISABLED = "DISABLED",
        /** Tiers are enabled but not yet active */
        DRAFT = "DRAFT",
        /** Tiers are active */
        ACTIVE = "ACTIVE",
        /** Tiers are paused */
        PAUSED = "PAUSED"
    }
    /**
     * *Required.** Period of time used to calculate loyalty points for tier assignment.
     *
     * The loyalty points accumulated during this period determine if the account meets a tier's required point threshold.
     */
    interface RollingWindow {
        /**
         * Number of months to use for the rolling window period.
         *
         * Min: `"12"`
         *
         * Max: `"36"`
         */
        durationInMonths?: number;
    }
    interface TiersRollingUpdate {
    }
    interface CreateTierRequest {
        /** Tier to create. */
        tier: Tier;
    }
    interface CreateTierResponse {
        /** Created loyalty tier. */
        tier?: Tier;
    }
    interface BulkCreateTiersRequest {
        /** Tiers to create. */
        tiers?: Tier[];
    }
    interface BulkCreateTiersResponse {
        /** Created tiers. */
        results?: BulkTierResult[];
        /** Bulk action metadata. */
        bulkActionMetadata?: BulkActionMetadata;
    }
    /** Retrieved tiers. */
    interface BulkTierResult {
        /** Individual tier metadata. */
        itemMetadata?: ItemMetadata;
        /** Individual tier information. */
        item?: Tier;
    }
    interface ItemMetadata {
        /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
        _id?: string | null;
        /** Index of the item within the request array. Allows for correlation between request and response items. */
        originalIndex?: number;
        /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
        success?: boolean;
        /** Details about the error in case of failure. */
        error?: ApplicationError;
    }
    interface ApplicationError {
        /** Error code. */
        code?: string;
        /** Description of the error. */
        description?: string;
        /** Data related to the error. */
        data?: Record<string, any> | null;
    }
    interface BulkActionMetadata {
        /** Number of items that were successfully processed. */
        totalSuccesses?: number;
        /** Number of items that couldn't be processed. */
        totalFailures?: number;
        /** Number of failures without details because detailed failure threshold was exceeded. */
        undetailedFailures?: number;
    }
    interface GetTierRequest {
        /** ID of the tier to retrieve. */
        tierId: string;
    }
    interface GetTierResponse {
        /** Retrieved loyalty tier. */
        tier?: Tier;
    }
    interface UpdateTierRequest {
        /** Tier details to update. */
        tier: Tier;
    }
    interface UpdateTierResponse {
        /** Updated loyalty tier. */
        tier?: Tier;
    }
    interface TierRequiredPointsChanged {
        tier?: Tier;
    }
    interface DeleteTierRequest {
        /** ID of the tier to delete. */
        tierId: string;
        /** Current `revision` of the tier to delete. */
        revision?: string;
    }
    interface DeleteTierResponse {
    }
    interface ListTiersRequest {
    }
    interface ListTiersResponse {
        /** Retrieved loyalty tiers. */
        tiers?: Tier[];
    }
    interface CreateTiersProgramSettingsRequest {
        programSettings: TiersProgramSettings;
    }
    interface CreateTiersProgramSettingsResponse {
        programSettings?: TiersProgramSettings;
    }
    interface GetTiersProgramRequest {
    }
    interface GetTiersProgramResponse {
        tiers?: Tier[];
        programSettings?: TiersProgramSettings;
        vipPlan?: boolean;
    }
    interface GetTiersProgramSettingsRequest {
    }
    interface GetTiersProgramSettingsResponse {
        /** Tiers program settings. */
        programSettings?: TiersProgramSettings;
        /** Reserved for internal use. */
        vipPlan?: boolean;
    }
    interface UpdateTiersProgramSettingsRequest {
        /** Settings for the tiers program. */
        programSettings: TiersProgramSettings;
    }
    interface UpdateTiersProgramSettingsResponse {
        /** Updated program settings. */
        programSettings?: TiersProgramSettings;
    }
    interface RecalculateAllTiersRequest {
    }
    interface RecalculateAllTiersResponse {
    }
    /**
     * Creates a tier.
     *
     * The name for a tier and the amount of required points to qualify for a tier can only exist for a single tier.
     * Attempts to create a tier with a `tierDefinition.name` or `requiredPoints` that already exists will return an error.
     *
     * To create up to 20 tiers at once, use [`bulkCreateTiers()`](#bulkcreatetiers).
     *
     * >**Note:** You must have a [Business VIP Premium plan](https://support.wix.com/en/article/business-vip-premium-plan-overview) or a [Scale Premium plan](https://support.wix.com/en/article/editor-x-scale-premium-plan-overview) to add tiers.
     *
     * This function is not a universal function and runs only on the backend.
     * @param tier - Tier to create.
     * @public
     * @documentationMaturity preview
     * @requiredField tier
     * @adminMethod
     */
    function createTier(tier: Tier): Promise<CreateTierResponse>;
    /**
     * Creates up to 20 tiers.
     *
     * The name for a tier and the amount of required points to qualify for a tier can only exist for a single tier.
     * Attempts to create a tier with a `tierDefinition.name` or `requiredPoints` that already exists will return an error.
     *
     * To create a single tier, use [`createTier()`](#createtier).
     *
     * >**Note:** You must have a [Business VIP Premium plan](https://support.wix.com/en/article/business-vip-premium-plan-overview) or a [Scale Premium plan](https://support.wix.com/en/article/editor-x-scale-premium-plan-overview) to add tiers.
     *
     * This function is not a universal function and runs only on the backend.
     * @param tiers - Tiers to create.
     * @public
     * @documentationMaturity preview
     * @requiredField tiers
     * @adminMethod
     */
    function bulkCreateTiers(tiers: Tier[]): Promise<BulkCreateTiersResponse>;
    /**
     * Retrieves a loyalty tier.
     *
     * To retrieve a list of all of a site's tiers, use [`listTiers()`](#listtiers).
     * @param tierId - ID of the tier to retrieve.
     * @public
     * @documentationMaturity preview
     * @requiredField tierId
     */
    function getTier(tierId: string): Promise<GetTierResponse>;
    /**
     * Updates a loyalty tier.
     *
     * Use this endpoint to update tier-specific settings, such as the name and the required points
     * threshold of an individual loyalty tier. To update global settings that apply to all of a site's loyalty tiers,
     * use [`updateTiersProgramSettings()`](#updatetiersprogramsettings).
     *
     * This function is not a universal function and runs only on the backend.
     * @param _id - Tier ID.
     * @public
     * @documentationMaturity preview
     * @requiredField _id
     * @requiredField tier
     * @requiredField tier.revision
     * @param tier - Tier info to update.
     * @adminMethod
     */
    function updateTier(_id: string | null, tier: UpdateTier): Promise<UpdateTierResponse>;
    interface UpdateTier {
        /**
         * Tier ID.
         * @readonly
         */
        _id?: string | null;
        /** Information about the tier. */
        tierDefinition?: TierDefinition;
        /**
         * The amount of points required to be in this tier.
         *
         * Min: `"0"`
         *
         * Max: `"9999999"`
         */
        requiredPoints?: number;
        /**
         * Revision number, which increments by `"1"` each time the loyalty tier is updated.
         *
         * To prevent conflicting changes, the current `revision` must be passed when updating the loyalty tier.
         * @readonly
         */
        revision?: string | null;
        /**
         * Date and time the tier was created.
         * @readonly
         */
        _createdDate?: Date;
        /**
         * Date and time the tier was last updated.
         * @readonly
         */
        _updatedDate?: Date;
    }
    /**
     * Deletes a loyalty tier.
     *
     * This function is not a universal function and runs only on the backend.
     * @param tierId - ID of the tier to delete.
     * @param revision - Current `revision` of the tier to delete.
     * @public
     * @documentationMaturity preview
     * @requiredField revision
     * @requiredField tierId
     * @adminMethod
     */
    function deleteTier(tierId: string, revision: string): Promise<void>;
    /**
     * Retrieves a list of a site's tiers.
     *
     * To retrieve a specific tier, use [`getTier()`](#gettier).
     * @public
     * @documentationMaturity preview
     */
    function listTiers(): Promise<ListTiersResponse>;
    /**
     * Retrieves the settings for the tiers program.
     *
     * Tiers program settings apply globally to all tiers in the program.
     * @public
     * @documentationMaturity preview
     */
    function getTiersProgramSettings(): Promise<GetTiersProgramSettingsResponse>;
    /**
     * Updates the global settings of a loyalty tier program.
     *
     * Use this endpoint to update settings that apply to all of a site's loyalty tiers.
     * To update tier-specific settings for an individual tier, use
     * [`updateTier()`](#updatetier).
     *
     * By default, the `status` of a tiers program is set to `"DISABLED"` and must be manually updated to `"ACTIVE"` using
     * this endpoint or through a site owner's [dashboard](https://manage.wix.com/account/site-selector/?actionUrl=https%3A%2F%2Fwww.wix.com%2Fdashboard%2F%7BmetaSiteId%7D%2Floyalty-accounts%2Fmanage%3Ftab%3Dpoints-and-rewards&title=Select+a+Site&primaryButtonText=Select+Site).
     *
     * >**Note:** The `status`, `revision`, and `rollingWindow` parameters must be passed to update the tiers program settings. The `baseTierDefinition` fields are not required, however, if you don't pass them they will reset to their default values of empty fields.
     *
     * This function is not a universal function and runs only on the backend.
     * @param programSettings - Settings for the tiers program.
     * @public
     * @documentationMaturity preview
     * @requiredField programSettings
     * @requiredField programSettings.revision
     * @requiredField programSettings.status
     * @adminMethod
     */
    function updateTiersProgramSettings(programSettings: TiersProgramSettings): Promise<UpdateTiersProgramSettingsResponse>;
    const loyaltyV1Tier_universal_d___debug: typeof __debug;
    type loyaltyV1Tier_universal_d_Tier = Tier;
    type loyaltyV1Tier_universal_d_TierDefinition = TierDefinition;
    type loyaltyV1Tier_universal_d_TiersProgramSettingsChanged = TiersProgramSettingsChanged;
    type loyaltyV1Tier_universal_d_TiersProgramSettings = TiersProgramSettings;
    type loyaltyV1Tier_universal_d_TiersProgramSettingsPeriodOneOf = TiersProgramSettingsPeriodOneOf;
    type loyaltyV1Tier_universal_d_Status = Status;
    const loyaltyV1Tier_universal_d_Status: typeof Status;
    type loyaltyV1Tier_universal_d_RollingWindow = RollingWindow;
    type loyaltyV1Tier_universal_d_TiersRollingUpdate = TiersRollingUpdate;
    type loyaltyV1Tier_universal_d_CreateTierRequest = CreateTierRequest;
    type loyaltyV1Tier_universal_d_CreateTierResponse = CreateTierResponse;
    type loyaltyV1Tier_universal_d_BulkCreateTiersRequest = BulkCreateTiersRequest;
    type loyaltyV1Tier_universal_d_BulkCreateTiersResponse = BulkCreateTiersResponse;
    type loyaltyV1Tier_universal_d_BulkTierResult = BulkTierResult;
    type loyaltyV1Tier_universal_d_ItemMetadata = ItemMetadata;
    type loyaltyV1Tier_universal_d_ApplicationError = ApplicationError;
    type loyaltyV1Tier_universal_d_BulkActionMetadata = BulkActionMetadata;
    type loyaltyV1Tier_universal_d_GetTierRequest = GetTierRequest;
    type loyaltyV1Tier_universal_d_GetTierResponse = GetTierResponse;
    type loyaltyV1Tier_universal_d_UpdateTierRequest = UpdateTierRequest;
    type loyaltyV1Tier_universal_d_UpdateTierResponse = UpdateTierResponse;
    type loyaltyV1Tier_universal_d_TierRequiredPointsChanged = TierRequiredPointsChanged;
    type loyaltyV1Tier_universal_d_DeleteTierRequest = DeleteTierRequest;
    type loyaltyV1Tier_universal_d_DeleteTierResponse = DeleteTierResponse;
    type loyaltyV1Tier_universal_d_ListTiersRequest = ListTiersRequest;
    type loyaltyV1Tier_universal_d_ListTiersResponse = ListTiersResponse;
    type loyaltyV1Tier_universal_d_CreateTiersProgramSettingsRequest = CreateTiersProgramSettingsRequest;
    type loyaltyV1Tier_universal_d_CreateTiersProgramSettingsResponse = CreateTiersProgramSettingsResponse;
    type loyaltyV1Tier_universal_d_GetTiersProgramRequest = GetTiersProgramRequest;
    type loyaltyV1Tier_universal_d_GetTiersProgramResponse = GetTiersProgramResponse;
    type loyaltyV1Tier_universal_d_GetTiersProgramSettingsRequest = GetTiersProgramSettingsRequest;
    type loyaltyV1Tier_universal_d_GetTiersProgramSettingsResponse = GetTiersProgramSettingsResponse;
    type loyaltyV1Tier_universal_d_UpdateTiersProgramSettingsRequest = UpdateTiersProgramSettingsRequest;
    type loyaltyV1Tier_universal_d_UpdateTiersProgramSettingsResponse = UpdateTiersProgramSettingsResponse;
    type loyaltyV1Tier_universal_d_RecalculateAllTiersRequest = RecalculateAllTiersRequest;
    type loyaltyV1Tier_universal_d_RecalculateAllTiersResponse = RecalculateAllTiersResponse;
    const loyaltyV1Tier_universal_d_createTier: typeof createTier;
    const loyaltyV1Tier_universal_d_bulkCreateTiers: typeof bulkCreateTiers;
    const loyaltyV1Tier_universal_d_getTier: typeof getTier;
    const loyaltyV1Tier_universal_d_updateTier: typeof updateTier;
    type loyaltyV1Tier_universal_d_UpdateTier = UpdateTier;
    const loyaltyV1Tier_universal_d_deleteTier: typeof deleteTier;
    const loyaltyV1Tier_universal_d_listTiers: typeof listTiers;
    const loyaltyV1Tier_universal_d_getTiersProgramSettings: typeof getTiersProgramSettings;
    const loyaltyV1Tier_universal_d_updateTiersProgramSettings: typeof updateTiersProgramSettings;
    namespace loyaltyV1Tier_universal_d {
        export { loyaltyV1Tier_universal_d___debug as __debug, loyaltyV1Tier_universal_d_Tier as Tier, loyaltyV1Tier_universal_d_TierDefinition as TierDefinition, loyaltyV1Tier_universal_d_TiersProgramSettingsChanged as TiersProgramSettingsChanged, loyaltyV1Tier_universal_d_TiersProgramSettings as TiersProgramSettings, loyaltyV1Tier_universal_d_TiersProgramSettingsPeriodOneOf as TiersProgramSettingsPeriodOneOf, loyaltyV1Tier_universal_d_Status as Status, loyaltyV1Tier_universal_d_RollingWindow as RollingWindow, loyaltyV1Tier_universal_d_TiersRollingUpdate as TiersRollingUpdate, loyaltyV1Tier_universal_d_CreateTierRequest as CreateTierRequest, loyaltyV1Tier_universal_d_CreateTierResponse as CreateTierResponse, loyaltyV1Tier_universal_d_BulkCreateTiersRequest as BulkCreateTiersRequest, loyaltyV1Tier_universal_d_BulkCreateTiersResponse as BulkCreateTiersResponse, loyaltyV1Tier_universal_d_BulkTierResult as BulkTierResult, loyaltyV1Tier_universal_d_ItemMetadata as ItemMetadata, loyaltyV1Tier_universal_d_ApplicationError as ApplicationError, loyaltyV1Tier_universal_d_BulkActionMetadata as BulkActionMetadata, loyaltyV1Tier_universal_d_GetTierRequest as GetTierRequest, loyaltyV1Tier_universal_d_GetTierResponse as GetTierResponse, loyaltyV1Tier_universal_d_UpdateTierRequest as UpdateTierRequest, loyaltyV1Tier_universal_d_UpdateTierResponse as UpdateTierResponse, loyaltyV1Tier_universal_d_TierRequiredPointsChanged as TierRequiredPointsChanged, loyaltyV1Tier_universal_d_DeleteTierRequest as DeleteTierRequest, loyaltyV1Tier_universal_d_DeleteTierResponse as DeleteTierResponse, loyaltyV1Tier_universal_d_ListTiersRequest as ListTiersRequest, loyaltyV1Tier_universal_d_ListTiersResponse as ListTiersResponse, loyaltyV1Tier_universal_d_CreateTiersProgramSettingsRequest as CreateTiersProgramSettingsRequest, loyaltyV1Tier_universal_d_CreateTiersProgramSettingsResponse as CreateTiersProgramSettingsResponse, loyaltyV1Tier_universal_d_GetTiersProgramRequest as GetTiersProgramRequest, loyaltyV1Tier_universal_d_GetTiersProgramResponse as GetTiersProgramResponse, loyaltyV1Tier_universal_d_GetTiersProgramSettingsRequest as GetTiersProgramSettingsRequest, loyaltyV1Tier_universal_d_GetTiersProgramSettingsResponse as GetTiersProgramSettingsResponse, loyaltyV1Tier_universal_d_UpdateTiersProgramSettingsRequest as UpdateTiersProgramSettingsRequest, loyaltyV1Tier_universal_d_UpdateTiersProgramSettingsResponse as UpdateTiersProgramSettingsResponse, loyaltyV1Tier_universal_d_RecalculateAllTiersRequest as RecalculateAllTiersRequest, loyaltyV1Tier_universal_d_RecalculateAllTiersResponse as RecalculateAllTiersResponse, loyaltyV1Tier_universal_d_createTier as createTier, loyaltyV1Tier_universal_d_bulkCreateTiers as bulkCreateTiers, loyaltyV1Tier_universal_d_getTier as getTier, loyaltyV1Tier_universal_d_updateTier as updateTier, loyaltyV1Tier_universal_d_UpdateTier as UpdateTier, loyaltyV1Tier_universal_d_deleteTier as deleteTier, loyaltyV1Tier_universal_d_listTiers as listTiers, loyaltyV1Tier_universal_d_getTiersProgramSettings as getTiersProgramSettings, loyaltyV1Tier_universal_d_updateTiersProgramSettings as updateTiersProgramSettings, };
    }
    export { loyaltyV1Account_universal_d as accounts, loyaltyV1Coupon_universal_d as coupons, loyaltyV1Program_universal_d as programs, loyaltyV1Reward_universal_d as rewards, loyaltyV1Tier_universal_d as tiers };
}
